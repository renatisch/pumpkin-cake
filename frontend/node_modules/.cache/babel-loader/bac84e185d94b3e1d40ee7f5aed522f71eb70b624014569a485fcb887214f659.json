{"ast":null,"code":"import _regeneratorRuntime from \"/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _objectWithoutProperties from \"/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _excluded = [\"doc_count\"];\n// src/transformRequest.ts\nimport deepmerge from \"deepmerge\";\n\n// src/filterUtils.ts\nvar TermFilter = function TermFilter(field, value) {\n  return {\n    term: _defineProperty({}, field, value)\n  };\n};\nvar MatchFilter = function MatchFilter(field, value) {\n  return {\n    match: _defineProperty({}, field, value)\n  };\n};\n\n// src/utils.ts\nvar getFacet = function getFacet(facet_attributes, attributeName) {\n  var f = facet_attributes.find(function (a) {\n    if (typeof a === \"string\") {\n      return a === attributeName;\n    }\n    return a.attribute === attributeName;\n  });\n  return f || null;\n};\nvar isNestedFacet = function isNestedFacet(facet) {\n  return typeof facet !== \"string\" && !!facet.nestedPath;\n};\nvar getFacetFieldType = function getFacetFieldType(facet_attributes, attribute) {\n  var _a;\n  var attributeKey = typeof attribute === \"string\" ? attribute : attribute.attribute;\n  if (facet_attributes.includes(attributeKey)) {\n    return \"string\";\n  }\n  return ((_a = facet_attributes.find(function (a) {\n    return (a == null ? void 0 : a.attribute) === attributeKey;\n  })) == null ? void 0 : _a.type) || \"string\";\n};\nvar _createElasticsearchQueryFromRequest = function createElasticsearchQueryFromRequest(requests) {\n  return requests.reduce(function (sum, request) {\n    return [].concat(_toConsumableArray(sum), [JSON.stringify({\n      index: request.indexName\n    }), \"\\n\", JSON.stringify(request.body), \"\\n\"]);\n  }, []).join(\"\");\n};\n\n// src/filters.ts\nvar transformNumericFilters = function transformNumericFilters(request, config) {\n  var _request$params = request.params,\n    params = _request$params === void 0 ? {} : _request$params;\n  var numericFilters = params.numericFilters;\n  if (!Array.isArray(numericFilters)) {\n    return [];\n  }\n  return numericFilters.reduce(function (sum, filter) {\n    var match,\n      field,\n      operator,\n      value,\n      maxValue = \"\";\n    var groups = filter.match(/([\\w\\.\\_\\-]+)\\s*(\\=|\\!\\=|\\>|\\>\\=|\\<|\\<\\=)\\s*(-?\\d+)/);\n    if (groups) {\n      var _groups = groups;\n      var _groups2 = _slicedToArray(_groups, 4);\n      match = _groups2[0];\n      field = _groups2[1];\n      operator = _groups2[2];\n      value = _groups2[3];\n    } else {\n      groups = filter.match(/([\\w\\.\\_\\-]+):\\s*(-?\\d+)\\s*([Tt][Oo])\\s*(-?\\d+)/);\n      if (!groups) {\n        throw new Error(\"Numeric filter \\\"\".concat(filter, \"\\\" could not be parsed. It should either be in the format \\\"attributeName operator operand\\\" or \\\"attributeName: lowerBound TO upperBound\\\"\"));\n      }\n      var _groups3 = groups;\n      var _groups4 = _slicedToArray(_groups3, 5);\n      match = _groups4[0];\n      field = _groups4[1];\n      value = _groups4[2];\n      operator = _groups4[3];\n      maxValue = _groups4[4];\n    }\n    var facetFilterMap = getFacetFilterMap(config.facet_attributes || [], config.filter_attributes || []);\n    var facetFilterConfig = facetFilterMap[field];\n    var getFilter = function getFilter(field2, operator2, value2) {\n      if (operator2 === \"=\") {\n        return {\n          term: _defineProperty({}, field2, value2)\n        };\n      } else if (operator2 === \"!=\") {\n        return {\n          bool: {\n            must_not: {\n              term: _defineProperty({}, field2, value2)\n            }\n          }\n        };\n      } else if (operator2 === \">\") {\n        return {\n          range: _defineProperty({}, field2, {\n            gt: value2\n          })\n        };\n      } else if (operator2 === \">=\") {\n        return {\n          range: _defineProperty({}, field2, {\n            gte: value2\n          })\n        };\n      } else if (operator2 === \"<\") {\n        return {\n          range: _defineProperty({}, field2, {\n            lt: value2\n          })\n        };\n      } else if (operator2 === \"<=\") {\n        return {\n          range: _defineProperty({}, field2, {\n            lte: value2\n          })\n        };\n      } else if (operator2.toUpperCase() === \"TO\") {\n        return {\n          range: _defineProperty({}, field2, {\n            gte: value2,\n            lte: maxValue\n          })\n        };\n      }\n    };\n    var esFilter = [];\n    if (facetFilterConfig.nestedPath) {\n      var nestedPathPresent = sum.find(function (filter2) {\n        return filter2.nested.path === facetFilterConfig.nestedPath;\n      });\n      if (nestedPathPresent) {\n        nestedPathPresent.nested.query.bool.filter.push(getFilter(facetFilterConfig.nestedPath + \".\" + facetFilterConfig.field, operator, value));\n      } else {\n        esFilter.push({\n          nested: {\n            path: facetFilterConfig.nestedPath,\n            inner_hits: {},\n            query: {\n              bool: {\n                filter: [getFilter(facetFilterConfig.nestedPath + \".\" + facetFilterConfig.field, operator, value)]\n              }\n            }\n          }\n        });\n      }\n    } else {\n      esFilter.push(getFilter(facetFilterConfig.field, operator, value));\n    }\n    return [].concat(_toConsumableArray(sum), esFilter);\n  }, []);\n};\nvar getFacetFilterMap = function getFacetFilterMap(facets, filters) {\n  return [].concat(_toConsumableArray(filters), _toConsumableArray(facets)).reduce(function (sum, filter) {\n    var f = typeof filter === \"string\" ? {\n      attribute: filter,\n      field: filter,\n      type: \"string\"\n    } : filter;\n    return _objectSpread(_objectSpread({}, sum), {}, _defineProperty({}, f.attribute, f));\n  }, {});\n};\nvar transformFacetFilters = function transformFacetFilters(request, config) {\n  var _request$params2 = request.params,\n    params = _request$params2 === void 0 ? {} : _request$params2;\n  var facetFilters = params.facetFilters;\n  if (!Array.isArray(facetFilters)) {\n    return [];\n  }\n  var facetFilterMap = getFacetFilterMap(config.facet_attributes || [], config.filter_attributes || []);\n  return facetFilters.reduce(function (sum, filter) {\n    if (Array.isArray(filter)) {\n      return [].concat(_toConsumableArray(sum), [{\n        bool: {\n          should: filter.reduce(function (sum2, filter2) {\n            var _filter2$split = filter2.split(\":\"),\n              _filter2$split2 = _slicedToArray(_filter2$split, 2),\n              facet = _filter2$split2[0],\n              value = _filter2$split2[1];\n            var facetFilterConfig = facetFilterMap[facet];\n            if (!facetFilterConfig) throw new Error(\"Facet \\\"\".concat(facet, \"\\\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.\"));\n            var field = facetFilterConfig.field;\n            var filterClauseFn = facetFilterConfig.filterQuery || TermFilter;\n            if (isNestedFacet(facetFilterConfig)) {\n              var nestedFilter = sum2.find(function (filter3) {\n                return filter3.nested && filter3.nested.path === facetFilterConfig.nestedPath;\n              });\n              if (nestedFilter) {\n                nestedFilter.nested.query.bool.should.push(filterClauseFn(\"\".concat(facetFilterConfig.nestedPath, \".\").concat(facetFilterConfig.field), value));\n                return sum2;\n              } else {\n                return [].concat(_toConsumableArray(sum2), [{\n                  nested: {\n                    inner_hits: {},\n                    path: facetFilterConfig.nestedPath,\n                    query: {\n                      bool: {\n                        should: [filterClauseFn(\"\".concat(facetFilterConfig.nestedPath, \".\").concat(facetFilterConfig.field), value)]\n                      }\n                    }\n                  }\n                }]);\n              }\n            }\n            return [].concat(_toConsumableArray(sum2), [filterClauseFn(field, value)]);\n          }, [])\n        }\n      }]);\n    } else if (typeof filter === \"string\") {\n      var _filter$split = filter.split(\":\"),\n        _filter$split2 = _slicedToArray(_filter$split, 2),\n        facet = _filter$split2[0],\n        value = _filter$split2[1];\n      var facetFilterConfig = facetFilterMap[facet];\n      if (!facetFilterConfig) throw new Error(\"Facet \\\"\".concat(facet, \"\\\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.\"));\n      var filterClauseFn = facetFilterConfig.filterQuery || TermFilter;\n      if (isNestedFacet(facetFilterConfig) && facetFilterConfig.nestedPath) {\n        var nestedFilter = sum.find(function (filter2) {\n          return filter2.nested && filter2.nested.path === facetFilterConfig.nestedPath + \".\";\n        });\n        if (nestedFilter) {\n          nestedFilter.nested.query.bool.should.push(filterClauseFn(\"\".concat(facetFilterConfig.nestedPath, \".\").concat(facetFilterConfig.field), value));\n          return sum;\n        } else {\n          return [].concat(_toConsumableArray(sum), [{\n            nested: {\n              inner_hits: {},\n              path: facetFilterConfig.nestedPath,\n              query: {\n                bool: {\n                  should: [filterClauseFn(\"\".concat(facetFilterConfig.nestedPath, \".\").concat(facetFilterConfig.field), value)]\n                }\n              }\n            }\n          }]);\n        }\n      }\n      return [].concat(_toConsumableArray(sum), [filterClauseFn(facetFilterConfig.field, value)]);\n    }\n  }, []);\n};\nvar transformQueryString = function transformQueryString() {\n  var facets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var filters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var queryString = arguments.length > 2 ? arguments[2] : undefined;\n  var regex = /([\\w\\.\\-]+)\\:/gi;\n  var filterMap = getFacetFilterMap(facets, filters);\n  return queryString.replace(regex, function (match, word) {\n    if (!filterMap[word]) {\n      throw new Error(\"Attribute \\\"\".concat(word, \"\\\" is not defined as an attribute in the facet or filter search settings\"));\n    }\n    if (!!filterMap[word].nestedPath) {\n      throw new Error(\"Attribute \\\"\".concat(word, \"\\\" is a nested field and cannot be used as a filter. Nested fields are supported in facetFilers or numericFilters.\"));\n    }\n    return filterMap[word].field + \":\";\n  });\n};\nvar transformBaseFilters = function transformBaseFilters(request, config) {\n  var _request$params3 = request.params,\n    params = _request$params3 === void 0 ? {} : _request$params3;\n  var filters = params.filters;\n  if (!filters || filters === \"\") {\n    return [];\n  }\n  var queryString = transformQueryString(config.facet_attributes, config.filter_attributes, filters);\n  return [{\n    query_string: {\n      query: queryString\n    }\n  }];\n};\nvar transformGeoFilters = function transformGeoFilters(request, config) {\n  if (!config.geo_attribute) {\n    return [];\n  }\n  var _request$params4 = request.params,\n    params = _request$params4 === void 0 ? {} : _request$params4;\n  var aroundLatLng = params.aroundLatLng,\n    aroundRadius = params.aroundRadius,\n    insideBoundingBox = params.insideBoundingBox;\n  if (insideBoundingBox) {\n    return [insideBoundingBoxFilter(insideBoundingBox, config.geo_attribute)];\n  }\n  if (aroundLatLng) {\n    var geoPoint = aroundLatLng.split(\",\");\n    return [{\n      geo_distance: _defineProperty({\n        distance: aroundRadius || \"1000m\"\n      }, config.geo_attribute, {\n        lat: geoPoint[0],\n        lon: geoPoint[1]\n      })\n    }];\n  }\n  return [];\n};\nfunction insideBoundingBoxFilter(insideBoundingBox, field) {\n  var geoBoundingboxFilter = function geoBoundingboxFilter(top, left, bottom, right) {\n    return {\n      geo_bounding_box: _defineProperty({}, field, {\n        top_right: {\n          lat: top,\n          lon: left\n        },\n        bottom_left: {\n          lat: bottom,\n          lon: right\n        }\n      })\n    };\n  };\n  if (typeof insideBoundingBox === \"string\") {\n    var _insideBoundingBox$sp = insideBoundingBox.split(\",\"),\n      _insideBoundingBox$sp2 = _slicedToArray(_insideBoundingBox$sp, 4),\n      top = _insideBoundingBox$sp2[0],\n      left = _insideBoundingBox$sp2[1],\n      bottom = _insideBoundingBox$sp2[2],\n      right = _insideBoundingBox$sp2[3];\n    return geoBoundingboxFilter(parseFloat(top), parseFloat(left), parseFloat(bottom), parseFloat(right));\n  } else if (Array.isArray(insideBoundingBox)) {\n    var geoBoundingboxes = insideBoundingBox.map(function (boundingBox) {\n      var _boundingBox = _slicedToArray(boundingBox, 4),\n        top = _boundingBox[0],\n        left = _boundingBox[1],\n        bottom = _boundingBox[2],\n        right = _boundingBox[3];\n      return geoBoundingboxFilter(parseFloat(top), parseFloat(left), parseFloat(bottom), parseFloat(right));\n    });\n    return {\n      bool: {\n        should: geoBoundingboxes\n      }\n    };\n  }\n}\n\n// src/sorting.ts\nfunction getSorting(request, config) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    var selectedSorting = Object.keys(config.sorting).find(function (key) {\n      if (request.indexName.endsWith(key)) {\n        return true;\n      }\n    });\n    if (!selectedSorting && !config.sorting.default) return {};\n    var sortOption = selectedSorting ? config.sorting[selectedSorting] : config.sorting.default;\n    if (Array.isArray(sortOption)) {\n      return {\n        sort: sortOption.map(function (sorting) {\n          return _defineProperty({}, sorting.field, sorting.order);\n        })\n      };\n    } else {\n      return {\n        sort: _defineProperty({}, sortOption.field, sortOption.order)\n      };\n    }\n  }\n  return {};\n}\nfunction getIndexName(indexName, config) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    var selectedSorting = Object.keys(config.sorting).find(function (key) {\n      if (indexName.endsWith(key)) {\n        return true;\n      }\n    });\n    if (selectedSorting) {\n      return indexName.replace(selectedSorting, \"\");\n    }\n  }\n  return indexName;\n}\n\n// src/transformRequest.ts\nvar createRegexQuery = function createRegexQuery(queryString) {\n  var query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n  query = query.split(\"\").map(function (char) {\n    if (/[a-z]/.test(char)) {\n      return \"[\".concat(char).concat(char.toUpperCase(), \"]\");\n    }\n    return char;\n  }).join(\"\");\n  query = \"\".concat(query, \".*\");\n  if (queryString.length > 2) {\n    query = \"([a-zA-Z]+ )+?\".concat(query);\n  }\n  return query;\n};\nvar TermAggregation = function TermAggregation(field, size, search) {\n  var searchInclude = search && search.length > 0 ? {\n    include: createRegexQuery(search)\n  } : {};\n  return {\n    terms: _objectSpread({\n      field: field,\n      size: size\n    }, searchInclude)\n  };\n};\nvar getTermAggregation = function getTermAggregation(facet, size, search) {\n  var aggEntries = {};\n  var AggregationFn = typeof facet !== \"string\" && facet.facetQuery ? facet.facetQuery : TermAggregation;\n  var getInnerAggs = function getInnerAggs(facetName, field) {\n    if (typeof facet === \"string\" || facet.type === \"string\") {\n      aggEntries = _defineProperty({}, facetName, AggregationFn(field, size, search));\n    } else if (facet.type === \"numeric\") {\n      var _aggEntries2;\n      aggEntries = (_aggEntries2 = {}, _defineProperty(_aggEntries2, facetName + \"$_stats\", {\n        stats: {\n          field: field\n        }\n      }), _defineProperty(_aggEntries2, facetName + \"$_entries\", AggregationFn(field, size, search)), _aggEntries2);\n    }\n    return aggEntries;\n  };\n  if (typeof facet === \"string\") {\n    return getInnerAggs(facet, facet);\n  } else if (isNestedFacet(facet)) {\n    return _defineProperty({}, \"\".concat(facet.nestedPath, \".\"), {\n      nested: {\n        path: facet.nestedPath\n      },\n      aggs: getInnerAggs(facet.attribute, \"\".concat(facet.nestedPath, \".\").concat(facet.field))\n    });\n  } else {\n    return getInnerAggs(facet.attribute, facet.field);\n  }\n};\nvar getAggs = function getAggs(request, config, queryRuleActions) {\n  var _request$params5 = request.params,\n    params = _request$params5 === void 0 ? {} : _request$params5,\n    type = request.type;\n  var facets = params.facets,\n    maxValuesPerFacet = params.maxValuesPerFacet,\n    facetName = params.facetName,\n    facetQuery = params.facetQuery;\n  var maxFacetSize = maxValuesPerFacet || 10;\n  var facetAttributes = config.facet_attributes || [];\n  if (facetName) {\n    var facet = getFacet(facetAttributes, facetName);\n    if (!facet) return null;\n    return getTermAggregation(facet, maxFacetSize, facetQuery);\n  } else if (Array.isArray(facets)) {\n    var facetAttibutes = config.facet_attributes || [];\n    if (queryRuleActions.facetAttributesOrder) {\n      facetAttibutes = queryRuleActions.facetAttributesOrder.map(function (attribute) {\n        return getFacet(config.facet_attributes || [], attribute);\n      }).filter(function (x) {\n        return x !== null;\n      });\n    }\n    var facetAttributes2 = facets[0] === \"*\" ? facetAttibutes : facets.map(function (facetAttribute) {\n      return getFacet(config.facet_attributes || [], facetAttribute);\n    }).filter(function (x) {\n      return x !== null;\n    });\n    return facetAttributes2.reduce(function (sum, facet) {\n      return deepmerge(sum, getTermAggregation(facet, maxFacetSize, \"\"));\n    }, {}) || {};\n  } else if (typeof facets === \"string\") {\n    var field = getFacet(config.facet_attributes || [], facets);\n    if (!field) return {};\n    return getTermAggregation(field, maxFacetSize, \"\");\n  }\n};\nfunction queryRulesWrapper(organicQuery, queryRuleActions) {\n  if (queryRuleActions.touched) {\n    return {\n      function_score: {\n        query: {\n          pinned: {\n            ids: queryRuleActions.pinnedDocs,\n            organic: organicQuery\n          }\n        },\n        functions: queryRuleActions.boostFunctions\n      }\n    };\n  }\n  return organicQuery;\n}\nfunction RelevanceQueryMatch(query, search_attributes) {\n  var getFieldsMap = function getFieldsMap(boostMultiplier) {\n    return search_attributes.map(function (attribute) {\n      return typeof attribute === \"string\" ? attribute : \"\".concat(attribute.field, \"^\").concat((attribute.weight || 1) * boostMultiplier);\n    });\n  };\n  return {\n    bool: {\n      should: [{\n        bool: {\n          should: [{\n            multi_match: {\n              query: query,\n              fields: getFieldsMap(1),\n              fuzziness: \"AUTO:4,8\"\n            }\n          }, {\n            multi_match: {\n              query: query,\n              fields: getFieldsMap(0.5),\n              type: \"bool_prefix\"\n            }\n          }]\n        }\n      }, {\n        multi_match: {\n          query: query,\n          type: \"phrase\",\n          fields: getFieldsMap(2)\n        }\n      }]\n    }\n  };\n}\nvar getQuery = function getQuery(request, config, queryRuleActions, requestOptions) {\n  var _a, _b, _c;\n  var query = queryRuleActions.query;\n  var searchAttributes = config.search_attributes;\n  var filters = [].concat(_toConsumableArray(transformFacetFilters(request, config)), _toConsumableArray(transformNumericFilters(request, config)), _toConsumableArray(transformBaseFilters(request, config)), _toConsumableArray(transformGeoFilters(request, config)), _toConsumableArray(((_a = requestOptions == null ? void 0 : requestOptions.getBaseFilters) == null ? void 0 : _a.call(requestOptions)) || []), _toConsumableArray(queryRuleActions.baseFilters));\n  var organicQuery = typeof query === \"string\" && query !== \"\" ? (requestOptions == null ? void 0 : requestOptions.getQuery) ? requestOptions.getQuery(query, searchAttributes, config) : RelevanceQueryMatch(query, searchAttributes) : {\n    match_all: {}\n  };\n  var hasKnn = typeof (requestOptions == null ? void 0 : requestOptions.getKnnQuery) === \"function\";\n  var hasNoQuery = ((_b = requestOptions == null ? void 0 : requestOptions.getQuery) == null ? void 0 : _b.call(requestOptions, query, searchAttributes, config)) === false;\n  if (hasNoQuery || hasKnn && query === \"\") {\n    organicQuery = {\n      match_all: {}\n    };\n  }\n  var queryDsl = {\n    bool: {\n      filter: filters,\n      must: queryRuleActions.touched ? queryRulesWrapper(organicQuery, queryRuleActions) : organicQuery\n    }\n  };\n  var knnQueryDsl = null;\n  if (hasKnn && query !== \"\") {\n    knnQueryDsl = _objectSpread({\n      filter: filters\n    }, ((_c = requestOptions == null ? void 0 : requestOptions.getKnnQuery) == null ? void 0 : _c.call(requestOptions, query, searchAttributes, config)) || {});\n  }\n  if (query !== \"\" && hasNoQuery && hasKnn && knnQueryDsl) {\n    return {\n      knn: knnQueryDsl\n    };\n  }\n  var size = getHitsPerPage(request);\n  return {\n    query: queryDsl,\n    knn: knnQueryDsl ? knnQueryDsl : void 0,\n    rank: hasKnn && !hasNoQuery && size > 0 && query !== \"\" ? {\n      rrf: {\n        window_size: size\n      }\n    } : void 0\n  };\n};\nvar getHitsPerPage = function getHitsPerPage(request) {\n  var _request$params6 = request.params,\n    params = _request$params6 === void 0 ? {} : _request$params6;\n  return params.hitsPerPage == null ? 20 : params.hitsPerPage;\n};\nvar getResultsSize = function getResultsSize(request, config) {\n  var _request$params7 = request.params,\n    params = _request$params7 === void 0 ? {} : _request$params7;\n  var hitsPerPage = getHitsPerPage(request);\n  return {\n    size: hitsPerPage,\n    from: (params.page || 0) * hitsPerPage\n  };\n};\nvar getHitFields = function getHitFields(request, config) {\n  var _request$params8 = request.params,\n    params = _request$params8 === void 0 ? {} : _request$params8;\n  var attributesToRetrieve = params.attributesToRetrieve;\n  var sourceFields = /* @__PURE__ */new Set([].concat(_toConsumableArray(config.result_attributes || []), _toConsumableArray(config.highlight_attributes || []), _toConsumableArray(config.geo_attribute ? [config.geo_attribute] : [])));\n  var runtimeFields = Object.keys(config.runtime_mappings || {});\n  var fields = runtimeFields.reduce(function (sum, field) {\n    var _a;\n    if ((_a = config.result_attributes) == null ? void 0 : _a.includes(field)) {\n      return [field].concat(_toConsumableArray(sum));\n    }\n    return sum;\n  }, []);\n  return _objectSpread({\n    _source: {\n      includes: Array.from(sourceFields)\n    }\n  }, fields.length > 0 ? {\n    fields: fields\n  } : {});\n};\nvar getSnippetFieldLength = function getSnippetFieldLength(attribute) {\n  var defaultMatch = {\n    attribute: attribute,\n    length: 100\n  };\n  if (!attribute.includes(\":\")) {\n    return defaultMatch;\n  }\n  var match = attribute.match(/(.+)\\:(\\d+)/);\n  if (!match) return defaultMatch;\n  return {\n    attribute: match[1],\n    length: parseInt(match[2])\n  };\n};\nvar getHighlightFields = function getHighlightFields(request, config) {\n  var _a, _b;\n  var _request$params9 = request.params,\n    params = _request$params9 === void 0 ? {} : _request$params9;\n  var attributesToHighlight = params.attributesToHighlight;\n  var highlightFields = ((_a = config.highlight_attributes) == null ? void 0 : _a.reduce(function (sum, field) {\n    return _objectSpread(_objectSpread({}, sum), {}, _defineProperty({}, field, {\n      number_of_fragments: 0\n    }));\n  }, {})) || {};\n  var snippetFields = ((_b = config.snippet_attributes) == null ? void 0 : _b.reduce(function (sum, attribute) {\n    return _objectSpread(_objectSpread({}, sum), {}, _defineProperty({}, getSnippetFieldLength(attribute).attribute, {\n      number_of_fragments: 5,\n      fragment_size: getSnippetFieldLength(attribute).length\n    }));\n  }, {})) || {};\n  if (Object.keys(highlightFields).length === 0 && Object.keys(snippetFields).length === 0) {\n    return {};\n  }\n  return {\n    highlight: {\n      pre_tags: [\"<em>\"],\n      post_tags: [\"</em>\"],\n      fields: _objectSpread(_objectSpread({}, highlightFields), snippetFields)\n    }\n  };\n};\nvar getRuntimeMappings = function getRuntimeMappings(request, config) {\n  if (!config.runtime_mappings) {\n    return {};\n  }\n  return {\n    runtime_mappings: config.runtime_mappings\n  };\n};\nfunction transformRequest(request, config, queryRuleActions, requestOptions) {\n  var body = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n    aggs: getAggs(request, config, queryRuleActions)\n  }, getQuery(request, config, queryRuleActions, requestOptions)), getResultsSize(request, config)), getHitFields(request, config)), getHighlightFields(request, config)), getSorting(request, config)), getRuntimeMappings(request, config));\n  return body;\n}\n\n// src/highlightUtils.ts\nfunction highlightTerm(value, query) {\n  var regex = new RegExp(query, \"gi\");\n  return value.replace(regex, function (match) {\n    return \"<em>\".concat(match, \"</em>\");\n  });\n}\nfunction isAllowableHighlightField(fieldKey, highlightFields) {\n  return highlightFields.findIndex(function (highlightField) {\n    if (highlightField.indexOf(\"*\") < 0) {\n      return highlightField === fieldKey;\n    }\n    var safeHighlightField = highlightField.replace(/[.+?^$|\\{\\}\\(\\)\\[\\]\\\\]/g, \"\\\\$&\");\n    var regex = new RegExp(\"^\".concat(safeHighlightField.replace(/\\*/g, \".*\"), \"$\"));\n    return regex.test(fieldKey);\n  }) >= 0;\n}\nfunction getHighlightFields2(hit) {\n  var preTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"<ais-highlight-0000000000>\";\n  var postTag = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"<ais-highlight-0000000000/>\";\n  var fields = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  var _hit$_source = hit._source,\n    _source = _hit$_source === void 0 ? {} : _hit$_source,\n    _hit$highlight = hit.highlight,\n    highlight = _hit$highlight === void 0 ? {} : _hit$highlight;\n  var combinedKeys = _objectSpread(_objectSpread({}, _source), highlight);\n  var highlightFields = fields.map(function (field) {\n    return getSnippetFieldLength(field).attribute;\n  });\n  var hitHighlights = Object.keys(combinedKeys).reduce(function (sum, fieldKey) {\n    var fieldValue = _source[fieldKey];\n    var highlightedMatch = highlight[fieldKey] || null;\n    if (!isAllowableHighlightField(fieldKey, highlightFields)) {\n      return sum;\n    }\n    if (Array.isArray(fieldValue) && !highlightedMatch) {\n      return _objectSpread(_objectSpread({}, sum), {}, _defineProperty({}, fieldKey, fieldValue.map(function (value) {\n        return {\n          matchLevel: \"none\",\n          matchedWords: [],\n          value: value.toString()\n        };\n      })));\n    } else if (Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) {\n      return _objectSpread(_objectSpread({}, sum), {}, _defineProperty({}, fieldKey, highlightedMatch.map(function (highlightedMatch2) {\n        var matchWords = Array.from(highlightedMatch2.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(function (match) {\n          return match[1];\n        });\n        return {\n          fullyHighlighted: false,\n          matchLevel: \"full\",\n          matchedWords: matchWords,\n          value: highlightedMatch2.toString().replace(/\\<em\\>/g, preTag).replace(/\\<\\/em\\>/g, postTag)\n        };\n      })));\n    } else if (!Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch) || !fieldValue && Array.isArray(highlightedMatch) && highlightedMatch.length > 0) {\n      var singleMatch = highlightedMatch[0];\n      var matchWords = Array.from(singleMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(function (match) {\n        return match[1];\n      });\n      var x = {\n        fullyHighlighted: false,\n        matchLevel: \"full\",\n        matchedWords: matchWords,\n        value: singleMatch.toString().replace(/\\<em\\>/g, preTag).replace(/\\<\\/em\\>/g, postTag)\n      };\n      return _objectSpread(_objectSpread({}, sum), {}, _defineProperty({}, fieldKey, x));\n    }\n    return _objectSpread(_objectSpread({}, sum), {}, _defineProperty({}, fieldKey, {\n      matchLevel: \"none\",\n      matchedWords: [],\n      value: fieldValue != void 0 ? fieldValue.toString() : \"\"\n    }));\n  }, {});\n  return hitHighlights;\n}\n\n// src/transformResponse.ts\nvar getHits = function getHits(response, config, instantsearchRequest) {\n  var hits = response.hits;\n  var _config$highlight_att = config.highlight_attributes,\n    highlight_attributes = _config$highlight_att === void 0 ? [] : _config$highlight_att,\n    _config$snippet_attri = config.snippet_attributes,\n    snippet_attributes = _config$snippet_attri === void 0 ? [] : _config$snippet_attri;\n  return hits.hits.map(function (hit) {\n    var _a, _b, _c, _d, _e, _f;\n    return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({\n      objectID: hit._id,\n      _index: hit == null ? void 0 : hit._index\n    }, hit._source || {}), hit.fields || {}), hit.inner_hits ? {\n      inner_hits: hit.inner_hits\n    } : {}), highlight_attributes.length > 0 ? {\n      _highlightResult: getHighlightFields2(hit, (_a = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _a.highlightPreTag, (_b = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _b.highlightPostTag, highlight_attributes)\n    } : {}), snippet_attributes.length > 0 ? {\n      _snippetResult: getHighlightFields2(hit, (_c = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _c.highlightPreTag, (_d = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _d.highlightPostTag, config.snippet_attributes)\n    } : {}), config.geo_attribute && ((_e = hit._source) == null ? void 0 : _e[config.geo_attribute]) ? {\n      _geoloc: convertLatLng((_f = hit._source) == null ? void 0 : _f[config.geo_attribute])\n    } : {});\n  });\n};\nfunction convertLatLng(value) {\n  if (typeof value === \"string\") {\n    var _value$split$map = value.split(\",\").map(function (v) {\n        return parseFloat(v);\n      }),\n      _value$split$map2 = _slicedToArray(_value$split$map, 2),\n      lat = _value$split$map2[0],\n      lng = _value$split$map2[1];\n    return {\n      lat: lat,\n      lng: lng\n    };\n  } else if (Array.isArray(value)) {\n    return {\n      lat: value[0],\n      lng: value[1]\n    };\n  } else if (typeof value === \"object\") {\n    if (\"lat\" in value && \"lon\" in value) {\n      return {\n        lat: parseFloat(value.lat),\n        lng: parseFloat(value.lon)\n      };\n    }\n  }\n  return null;\n}\nvar getFacets = function getFacets(response, config) {\n  if (!(response == null ? void 0 : response.aggregations)) {\n    return {};\n  }\n  var aggregations = Object.keys(response.aggregations).reduce(function (sum, key) {\n    var value = (response.aggregations || {})[key];\n    if (key.endsWith(\".\")) {\n      var doc_count = value.doc_count,\n        nestedAggregations = _objectWithoutProperties(value, _excluded);\n      return _objectSpread(_objectSpread({}, sum), nestedAggregations);\n    }\n    return _objectSpread(_objectSpread({}, sum), {}, _defineProperty({}, key, value));\n  }, {});\n  return Object.keys(aggregations).reduce(function (sum, f) {\n    var facet = f.split(\"$\")[0];\n    var fieldType = getFacetFieldType(config.facet_attributes || [], facet);\n    if (fieldType === \"numeric\") {\n      var facetValues = aggregations[facet + \"$_stats\"];\n      var buckets2 = aggregations[facet + \"$_entries\"].buckets;\n      return _objectSpread(_objectSpread({}, sum), {}, {\n        facets: _objectSpread(_objectSpread({}, sum.facets), {}, _defineProperty({}, facet, buckets2.reduce(function (sum2, bucket) {\n          return _objectSpread(_objectSpread({}, sum2), {}, _defineProperty({}, bucket.key, bucket.doc_count));\n        }, {}))),\n        facets_stats: _objectSpread(_objectSpread({}, sum.facets_stats), {}, _defineProperty({}, facet, {\n          min: facetValues.min,\n          avg: facetValues.avg,\n          max: facetValues.max,\n          sum: facetValues.sum\n        }))\n      });\n    }\n    var buckets = aggregations[facet].buckets;\n    return _objectSpread(_objectSpread({}, sum), {}, {\n      facets: _objectSpread(_objectSpread({}, sum.facets), {}, _defineProperty({}, facet, buckets.reduce(function (sum2, bucket) {\n        return _objectSpread(_objectSpread({}, sum2), {}, _defineProperty({}, bucket.key, bucket.doc_count));\n      }, {})))\n    });\n  }, {\n    facets: {},\n    facets_stats: {}\n  });\n};\nvar getRenderingContent = function getRenderingContent(config, queryRuleActions) {\n  var _a, _b;\n  var defaultOrder = (_a = config.facet_attributes) == null ? void 0 : _a.map(function (facet) {\n    return typeof facet === \"string\" ? facet : facet.attribute;\n  });\n  return {\n    renderingContent: {\n      facetOrdering: {\n        facets: {\n          order: queryRuleActions.facetAttributesOrder || defaultOrder || []\n        },\n        values: (_b = config.facet_attributes) == null ? void 0 : _b.reduce(function (sum, facet) {\n          var facetName = typeof facet === \"string\" ? facet : facet.attribute;\n          if (queryRuleActions.facetAttributesOrder && !queryRuleActions.facetAttributesOrder.includes(facetName)) {\n            return sum;\n          }\n          return _objectSpread(_objectSpread({}, sum), {}, _defineProperty({}, facetName, {\n            sortRemainingBy: \"count\"\n          }));\n        }, {})\n      }\n    }\n  };\n};\nvar getPageDetails = function getPageDetails(response, request, queryRuleActions) {\n  var _request$params10 = request.params,\n    params = _request$params10 === void 0 ? {} : _request$params10;\n  var _params$hitsPerPage = params.hitsPerPage,\n    hitsPerPage = _params$hitsPerPage === void 0 ? 20 : _params$hitsPerPage,\n    _params$page = params.page,\n    page = _params$page === void 0 ? 0 : _params$page;\n  var total = response.hits.total;\n  var totalHits = typeof total === \"number\" ? total : total == null ? void 0 : total.value;\n  var nbPages = hitsPerPage <= 0 ? 0 : Math.ceil((typeof total === \"number\" ? total : (total == null ? void 0 : total.value) || 0) / hitsPerPage);\n  return {\n    hitsPerPage: hitsPerPage,\n    processingTimeMS: response.took,\n    nbHits: totalHits,\n    page: page,\n    nbPages: nbPages,\n    query: queryRuleActions.query\n  };\n};\nfunction transformResponse(response, instantsearchRequest, config, queryRuleActions) {\n  try {\n    return _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n      appliedRules: queryRuleActions.ruleIds,\n      exhaustiveNbHits: true,\n      exhaustiveFacetsCount: true,\n      exhaustiveTypo: true,\n      exhaustive: {\n        facetsCount: true,\n        nbHits: true,\n        typo: true\n      }\n    }, getPageDetails(response, instantsearchRequest, queryRuleActions)), getRenderingContent(config, queryRuleActions)), getFacets(response, config)), {}, {\n      hits: getHits(response, config, instantsearchRequest),\n      index: instantsearchRequest.indexName,\n      params: new URLSearchParams(instantsearchRequest.params).toString()\n    }, queryRuleActions.userData.length > 0 ? {\n      userData: queryRuleActions.userData\n    } : {});\n  } catch (e) {\n    throw new Error(\"Error transforming Elasticsearch response for index\");\n  }\n}\nvar transformFacetValuesResponse = function transformFacetValuesResponse(response, instantsearchRequest) {\n  var _a, _b, _c;\n  var aggregations = response.aggregations || {};\n  var facetName = (_a = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _a.facetName;\n  var preTag = ((_b = instantsearchRequest.params) == null ? void 0 : _b.highlightPreTag) || \"<ais-highlight-0000000000>\";\n  var postTag = ((_c = instantsearchRequest.params) == null ? void 0 : _c.highlightPostTag) || \"<ais-highlight-0000000000/>\";\n  var agg = aggregations[Object.keys(aggregations)[0]];\n  if (agg && agg[facetName]) {\n    agg = agg[facetName];\n  }\n  return {\n    facetHits: agg.buckets.map(function (entry) {\n      return {\n        value: entry.key,\n        highlighted: highlightTerm(entry.key, instantsearchRequest.params.facetQuery || \"\").replace(/<\\em>/g, preTag).replace(/<\\/\\em>/g, postTag),\n        count: entry.doc_count\n      };\n    }),\n    exhaustiveFacetsCount: true,\n    processingTimeMS: response.took\n  };\n};\n\n// src/Transporter.ts\nvar authString = function authString(auth) {\n  if (typeof btoa === \"undefined\") {\n    return Buffer.from(auth.username + \":\" + auth.password).toString(\"base64\");\n  } else {\n    return btoa(auth.username + \":\" + auth.password);\n  }\n};\nfunction getHostFromCloud(cloudId) {\n  var cloudUrls;\n  if (typeof atob === \"undefined\") {\n    cloudUrls = Buffer.from(cloudId.split(\":\")[1], \"base64\").toString();\n  } else {\n    cloudUrls = atob(cloudId.split(\":\")[1]).split(\"$\");\n  }\n  return \"https://\".concat(cloudUrls[1], \".\").concat(cloudUrls[0]);\n}\nvar ESTransporter = /*#__PURE__*/function () {\n  function ESTransporter(config, settings) {\n    _classCallCheck(this, ESTransporter);\n    this.config = config;\n    this.settings = settings;\n  }\n  _createClass(ESTransporter, [{\n    key: \"createElasticsearchQueryFromRequest\",\n    value: function createElasticsearchQueryFromRequest(requests) {\n      return _createElasticsearchQueryFromRequest(requests);\n    }\n  }, {\n    key: \"performNetworkRequest\",\n    value: function () {\n      var _performNetworkRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(requests) {\n        var host;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.config.host === void 0 && this.config.cloud_id === void 0)) {\n                _context.next = 2;\n                break;\n              }\n              throw new Error(\"No Elasticsearch host or cloud_id specified. Please provide a host or cloud id in your Searchkit configuration.\");\n            case 2:\n              host = this.config.cloud_id ? getHostFromCloud(this.config.cloud_id) : this.config.host;\n              return _context.abrupt(\"return\", fetch(\"\".concat(host, \"/_msearch\"), {\n                headers: _objectSpread(_objectSpread(_objectSpread({}, this.config.apiKey ? {\n                  authorization: \"ApiKey \".concat(this.config.apiKey)\n                } : {}), {}, {\n                  \"content-type\": \"application/json\"\n                }, this.config.headers || {}), this.config.auth ? {\n                  Authorization: \"Basic \" + authString(this.config.auth)\n                } : {}),\n                body: this.createElasticsearchQueryFromRequest(requests),\n                method: \"POST\"\n              }));\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function performNetworkRequest(_x) {\n        return _performNetworkRequest.apply(this, arguments);\n      }\n      return performNetworkRequest;\n    }()\n  }, {\n    key: \"msearch\",\n    value: function () {\n      var _msearch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(requests) {\n        var _a, _b, _c, _d, _e, _f, response, responses;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return this.performNetworkRequest(requests);\n            case 3:\n              response = _context2.sent;\n              _context2.next = 6;\n              return response.json();\n            case 6:\n              responses = _context2.sent;\n              if (this.settings.debug) {\n                console.log(\"Elasticsearch response:\");\n                console.log(JSON.stringify(responses));\n              }\n              if (!(responses.status >= 500)) {\n                _context2.next = 13;\n                break;\n              }\n              console.error(JSON.stringify(responses));\n              throw new Error(\"Elasticsearch Internal Error: Check your elasticsearch instance to make sure it can recieve requests.\");\n            case 13:\n              if (!(responses.status === 401)) {\n                _context2.next = 18;\n                break;\n              }\n              console.error(JSON.stringify(responses));\n              throw new Error(\"Cannot connect to Elasticsearch. Check your connection host and auth details (username/password or API Key required). You can also provide a custom Elasticsearch transporter to the API Client. See https://www.searchkit.co/docs/guides/setup-elasticsearch#connecting-with-usernamepassword for more details.\");\n            case 18:\n              if (!(((_b = (_a = responses.responses) == null ? void 0 : _a[0]) == null ? void 0 : _b.status) === 403)) {\n                _context2.next = 23;\n                break;\n              }\n              console.error(JSON.stringify(responses));\n              throw new Error(\"Auth Error: You do not have permission to access this index. Check you are calling the right index (specified in frontend) and your API Key permissions has access to the index.\");\n            case 23:\n              if (!(responses.status === 404 || ((_d = (_c = responses.responses) == null ? void 0 : _c[0]) == null ? void 0 : _d.status) === 404)) {\n                _context2.next = 28;\n                break;\n              }\n              console.error(JSON.stringify(responses));\n              throw new Error(\"Elasticsearch index not found. Check your index name and make sure it exists.\");\n            case 28:\n              if (!(responses.status === 400 || ((_f = (_e = responses.responses) == null ? void 0 : _e[0]) == null ? void 0 : _f.status) === 400)) {\n                _context2.next = 31;\n                break;\n              }\n              console.error(JSON.stringify(responses));\n              throw new Error(\"Elasticsearch Bad Request. \\n          \\n          1. Check your query and make sure it is valid. \\n          2. Check the field mapping. See documentation to make sure you are using text types for searching and keyword fields for faceting\\n          3. Turn on debug mode to see the Elasticsearch query and the error response.\\n          \");\n            case 31:\n              return _context2.abrupt(\"return\", responses.responses);\n            case 34:\n              _context2.prev = 34;\n              _context2.t0 = _context2[\"catch\"](0);\n              throw _context2.t0;\n            case 37:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this, [[0, 34]]);\n      }));\n      function msearch(_x2) {\n        return _msearch.apply(this, arguments);\n      }\n      return msearch;\n    }()\n  }]);\n  return ESTransporter;\n}();\n\n// src/queryRules.ts\nvar getFacetFilters = function getFacetFilters(facetFilters) {\n  if (!facetFilters) {\n    return [];\n  }\n  if (typeof facetFilters === \"string\") {\n    var _facetFilters$split = facetFilters.split(\":\"),\n      _facetFilters$split2 = _slicedToArray(_facetFilters$split, 2),\n      attribute = _facetFilters$split2[0],\n      value = _facetFilters$split2[1];\n    return [{\n      attribute: attribute,\n      value: value\n    }];\n  } else {\n    return facetFilters.reduce(function (sum, filter) {\n      if (typeof filter === \"string\") {\n        var _filter$split3 = filter.split(\":\"),\n          _filter$split4 = _slicedToArray(_filter$split3, 2),\n          _attribute = _filter$split4[0],\n          _value = _filter$split4[1];\n        return [].concat(_toConsumableArray(sum), [{\n          attribute: _attribute,\n          value: _value\n        }]);\n      }\n      return [].concat(_toConsumableArray(sum), _toConsumableArray(getFacetFilters(filter)));\n    }, []);\n  }\n};\nvar getQueryRulesActionsFromRequest = function getQueryRulesActionsFromRequest(queryRules, request, config) {\n  var _a, _b, _c;\n  var queryContext = {\n    query: ((_a = request.params) == null ? void 0 : _a.query) || \"\",\n    context: ((_b = request.params) == null ? void 0 : _b.ruleContexts) || [],\n    filters: getFacetFilters((_c = request.params) == null ? void 0 : _c.facetFilters)\n  };\n  var satisfiedRules = getSatisfiedRules(queryContext, queryRules || []);\n  var actions = satisfiedRules.reduce(function (sum, rule) {\n    rule.actions.map(function (action) {\n      sum.touched = true;\n      if (action.action === \"PinnedResult\") {\n        var _sum$pinnedDocs;\n        (_sum$pinnedDocs = sum.pinnedDocs).push.apply(_sum$pinnedDocs, _toConsumableArray(action.documentIds));\n      } else if (action.action === \"QueryRewrite\") {\n        sum.query = action.query;\n      } else if (action.action === \"QueryBoost\") {\n        sum.boostFunctions.push({\n          filter: {\n            query_string: {\n              query: transformQueryString(config.facet_attributes, config.filter_attributes, action.query)\n            }\n          },\n          weight: action.weight\n        });\n      } else if (action.action === \"RenderUserData\") {\n        sum.userData.push(JSON.parse(action.userData));\n      } else if (action.action === \"RenderFacetsOrder\") {\n        sum.facetAttributesOrder = action.facetAttributesOrder;\n      } else if (action.action === \"QueryFilter\") {\n        sum.baseFilters.push({\n          query_string: {\n            query: transformQueryString(config.facet_attributes, config.filter_attributes, action.query)\n          }\n        });\n      }\n    });\n    return sum;\n  }, {\n    ruleIds: satisfiedRules.map(function (rule) {\n      return rule.id;\n    }),\n    pinnedDocs: [],\n    boostFunctions: [],\n    query: queryContext.query,\n    userData: [],\n    facetAttributesOrder: void 0,\n    touched: false,\n    baseFilters: []\n  });\n  return actions;\n};\nvar getSatisfiedRules = function getSatisfiedRules(queryContext, rules) {\n  return rules.filter(function (ruleOrs) {\n    return ruleOrs.conditions.find(function (rule) {\n      return rule.filter(function (condition) {\n        if (condition.context === \"query\" && condition.match_type === \"exact\") {\n          return condition.value === queryContext.query;\n        }\n        if (condition.context === \"query\" && condition.match_type === \"contains\") {\n          return queryContext.query.includes(condition.value);\n        }\n        if (condition.context === \"query\" && condition.match_type === \"prefix\") {\n          return queryContext.query.startsWith(condition.value);\n        }\n        if (condition.context === \"context\") {\n          return condition.value.some(function (value) {\n            return queryContext.context.includes(value);\n          });\n        }\n        if (condition.context === \"filterPresent\") {\n          return condition.values.every(function (value) {\n            return queryContext.filters.find(function (filter) {\n              return filter.attribute === value.attribute && filter.value === value.value;\n            }) !== void 0;\n          });\n        }\n        return false;\n      }).length === rule.length;\n    }) !== void 0;\n  });\n};\n\n// src/index.ts\nvar Searchkit = /*#__PURE__*/function () {\n  function Searchkit(config) {\n    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      debug: false\n    };\n    _classCallCheck(this, Searchkit);\n    this.config = config;\n    this.settings = settings;\n    this.transporter = \"msearch\" in config.connection ? config.connection : new ESTransporter(config.connection, settings);\n  }\n  _createClass(Searchkit, [{\n    key: \"performSearch\",\n    value: function () {\n      var _performSearch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(requests) {\n        var responses;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              if (this.settings.debug) {\n                console.log(\"Performing search with requests:\");\n                console.log(\"POST /_msearch\");\n                console.log(_createElasticsearchQueryFromRequest(requests));\n              }\n              _context3.next = 4;\n              return this.transporter.msearch(requests);\n            case 4:\n              responses = _context3.sent;\n              return _context3.abrupt(\"return\", responses);\n            case 8:\n              _context3.prev = 8;\n              _context3.t0 = _context3[\"catch\"](0);\n              console.error(_context3.t0);\n              return _context3.abrupt(\"return\", []);\n            case 12:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[0, 8]]);\n      }));\n      function performSearch(_x3) {\n        return _performSearch.apply(this, arguments);\n      }\n      return performSearch;\n    }()\n  }, {\n    key: \"handleInstantSearchRequests\",\n    value: function () {\n      var _handleInstantSearchRequests = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(instantsearchRequests, requestOptions) {\n        var _this = this;\n        var _a, _b, queryRules, requestQueryRuleActions, esRequests, esResponses, instantsearchResponses;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(!instantsearchRequests || Array.isArray(instantsearchRequests) === false)) {\n                _context4.next = 3;\n                break;\n              }\n              console.log({\n                instantsearchRequests: instantsearchRequests\n              });\n              throw new Error(\"No instantsearch requests provided. Check that the data you are providing from API request is correct. Likely you are not passing the request body correctly, its still a JSON string or the API is not a POST request.\");\n            case 3:\n              queryRules = this.config.search_settings.query_rules || [];\n              requestQueryRuleActions = instantsearchRequests.map(function (request) {\n                return getQueryRulesActionsFromRequest(queryRules, request, _this.config.search_settings);\n              });\n              esRequests = instantsearchRequests.map(function (request, i) {\n                return {\n                  body: transformRequest(request, _this.config.search_settings, requestQueryRuleActions[i], requestOptions),\n                  request: request,\n                  indexName: getIndexName(request.indexName, _this.config.search_settings)\n                };\n              });\n              if (!((_a = requestOptions == null ? void 0 : requestOptions.hooks) == null ? void 0 : _a.beforeSearch)) {\n                _context4.next = 10;\n                break;\n              }\n              _context4.next = 9;\n              return requestOptions.hooks.beforeSearch(esRequests);\n            case 9:\n              esRequests = _context4.sent;\n            case 10:\n              _context4.next = 12;\n              return this.performSearch(esRequests);\n            case 12:\n              esResponses = _context4.sent;\n              if (!((_b = requestOptions == null ? void 0 : requestOptions.hooks) == null ? void 0 : _b.afterSearch)) {\n                _context4.next = 17;\n                break;\n              }\n              _context4.next = 16;\n              return requestOptions.hooks.afterSearch(esRequests, esResponses);\n            case 16:\n              esResponses = _context4.sent;\n            case 17:\n              _context4.prev = 17;\n              instantsearchResponses = esResponses.map(function (response, i) {\n                var _a2;\n                if ((_a2 = instantsearchRequests[i].params) == null ? void 0 : _a2.facetName) {\n                  return transformFacetValuesResponse(response, instantsearchRequests[i]);\n                }\n                return transformResponse(response, instantsearchRequests[i], _this.config.search_settings, requestQueryRuleActions[i]);\n              });\n              return _context4.abrupt(\"return\", {\n                results: instantsearchResponses\n              });\n            case 22:\n              _context4.prev = 22;\n              _context4.t0 = _context4[\"catch\"](17);\n              console.error(_context4.t0);\n              throw new Error(\"Error transforming response. Check the afterSearch hook function is correct. Likely you are not returning the correct response object.\");\n            case 26:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[17, 22]]);\n      }));\n      function handleInstantSearchRequests(_x4, _x5) {\n        return _handleInstantSearchRequests.apply(this, arguments);\n      }\n      return handleInstantSearchRequests;\n    }()\n  }]);\n  return Searchkit;\n}();\nexport { ESTransporter, MatchFilter, TermFilter, Searchkit as default };","map":{"version":3,"names":["deepmerge","TermFilter","field","value","term","_defineProperty","MatchFilter","match","getFacet","facet_attributes","attributeName","f","find","a","attribute","isNestedFacet","facet","nestedPath","getFacetFieldType","_a","attributeKey","includes","type","createElasticsearchQueryFromRequest","requests","reduce","sum","request","concat","_toConsumableArray","JSON","stringify","index","indexName","body","join","transformNumericFilters","config","_request$params","params","numericFilters","Array","isArray","filter","operator","maxValue","groups","_groups","_groups2","_slicedToArray","Error","_groups3","_groups4","facetFilterMap","getFacetFilterMap","filter_attributes","facetFilterConfig","getFilter","field2","operator2","value2","bool","must_not","range","gt","gte","lt","lte","toUpperCase","esFilter","nestedPathPresent","filter2","nested","path","query","push","inner_hits","facets","filters","_objectSpread","transformFacetFilters","_request$params2","facetFilters","should","sum2","_filter2$split","split","_filter2$split2","filterClauseFn","filterQuery","nestedFilter","filter3","_filter$split","_filter$split2","transformQueryString","arguments","length","undefined","queryString","regex","filterMap","replace","word","transformBaseFilters","_request$params3","query_string","transformGeoFilters","geo_attribute","_request$params4","aroundLatLng","aroundRadius","insideBoundingBox","insideBoundingBoxFilter","geoPoint","geo_distance","distance","lat","lon","geoBoundingboxFilter","top","left","bottom","right","geo_bounding_box","top_right","bottom_left","_insideBoundingBox$sp","_insideBoundingBox$sp2","parseFloat","geoBoundingboxes","map","boundingBox","_boundingBox","getSorting","sorting","Object","keys","selectedSorting","key","endsWith","default","sortOption","sort","order","getIndexName","createRegexQuery","char","test","TermAggregation","size","search","searchInclude","include","terms","getTermAggregation","aggEntries","AggregationFn","facetQuery","getInnerAggs","facetName","_aggEntries2","stats","aggs","getAggs","queryRuleActions","_request$params5","maxValuesPerFacet","maxFacetSize","facetAttributes","facetAttibutes","facetAttributesOrder","x","facetAttributes2","facetAttribute","queryRulesWrapper","organicQuery","touched","function_score","pinned","ids","pinnedDocs","organic","functions","boostFunctions","RelevanceQueryMatch","search_attributes","getFieldsMap","boostMultiplier","weight","multi_match","fields","fuzziness","getQuery","requestOptions","_b","_c","searchAttributes","getBaseFilters","call","baseFilters","match_all","hasKnn","getKnnQuery","hasNoQuery","queryDsl","must","knnQueryDsl","knn","getHitsPerPage","rank","rrf","window_size","_request$params6","hitsPerPage","getResultsSize","_request$params7","from","page","getHitFields","_request$params8","attributesToRetrieve","sourceFields","Set","result_attributes","highlight_attributes","runtimeFields","runtime_mappings","_source","getSnippetFieldLength","defaultMatch","parseInt","getHighlightFields","_request$params9","attributesToHighlight","highlightFields","number_of_fragments","snippetFields","snippet_attributes","fragment_size","highlight","pre_tags","post_tags","getRuntimeMappings","transformRequest","highlightTerm","RegExp","isAllowableHighlightField","fieldKey","findIndex","highlightField","indexOf","safeHighlightField","getHighlightFields2","hit","preTag","postTag","_hit$_source","_hit$highlight","combinedKeys","hitHighlights","fieldValue","highlightedMatch","matchLevel","matchedWords","toString","highlightedMatch2","matchWords","matchAll","fullyHighlighted","singleMatch","getHits","response","instantsearchRequest","hits","_config$highlight_att","_config$snippet_attri","_d","_e","_f","objectID","_id","_index","_highlightResult","highlightPreTag","highlightPostTag","_snippetResult","_geoloc","convertLatLng","_value$split$map","v","_value$split$map2","lng","getFacets","aggregations","doc_count","nestedAggregations","_objectWithoutProperties","_excluded","fieldType","facetValues","buckets2","buckets","bucket","facets_stats","min","avg","max","getRenderingContent","defaultOrder","renderingContent","facetOrdering","values","sortRemainingBy","getPageDetails","_request$params10","_params$hitsPerPage","_params$page","total","totalHits","nbPages","Math","ceil","processingTimeMS","took","nbHits","transformResponse","appliedRules","ruleIds","exhaustiveNbHits","exhaustiveFacetsCount","exhaustiveTypo","exhaustive","facetsCount","typo","URLSearchParams","userData","e","transformFacetValuesResponse","agg","facetHits","entry","highlighted","count","authString","auth","btoa","Buffer","username","password","getHostFromCloud","cloudId","cloudUrls","atob","ESTransporter","settings","_classCallCheck","_createClass","_performNetworkRequest","_asyncToGenerator","_regeneratorRuntime","mark","_callee","host","wrap","_callee$","_context","prev","next","cloud_id","abrupt","fetch","headers","apiKey","authorization","Authorization","method","stop","performNetworkRequest","_x","apply","_msearch","_callee2","responses","_callee2$","_context2","sent","json","debug","console","log","status","error","t0","msearch","_x2","getFacetFilters","_facetFilters$split","_facetFilters$split2","_filter$split3","_filter$split4","getQueryRulesActionsFromRequest","queryRules","queryContext","context","ruleContexts","satisfiedRules","getSatisfiedRules","actions","rule","action","_sum$pinnedDocs","documentIds","parse","id","rules","ruleOrs","conditions","condition","match_type","startsWith","some","every","Searchkit","transporter","connection","_performSearch","_callee3","_callee3$","_context3","performSearch","_x3","_handleInstantSearchRequests","_callee4","instantsearchRequests","_this","requestQueryRuleActions","esRequests","esResponses","instantsearchResponses","_callee4$","_context4","search_settings","query_rules","i","hooks","beforeSearch","afterSearch","_a2","results","handleInstantSearchRequests","_x4","_x5"],"sources":["/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/transformRequest.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/filterUtils.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/utils.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/filters.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/sorting.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/highlightUtils.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/transformResponse.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/Transporter.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/queryRules.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/index.ts"],"sourcesContent":["import {\n  QueryDslQueryContainer,\n  RankContainer,\n  RrfRank\n} from '@elastic/elasticsearch/lib/api/types'\nimport deepmerge from 'deepmerge'\nimport {\n  transformBaseFilters,\n  transformFacetFilters,\n  transformGeoFilters,\n  transformNumericFilters\n} from './filters'\nimport { QueryRuleActions } from './queryRules'\nimport { getSorting } from './sorting'\nimport {\n  FacetAttribute,\n  KnnSearchQuery,\n  RequestOptions,\n  SearchAttribute,\n  SearchSettingsConfig\n} from './types'\nimport { AlgoliaMultipleQueriesQuery, ElasticsearchSearchRequest } from './types'\nimport { getFacet, isNestedFacet } from './utils'\n\nexport const createRegexQuery = (queryString: string) => {\n  let query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n  query = query\n    .split('')\n    .map((char) => {\n      if (/[a-z]/.test(char)) {\n        return `[${char}${char.toUpperCase()}]`\n      }\n      return char\n    })\n    .join('')\n  query = `${query}.*`\n  if (queryString.length > 2) {\n    query = `([a-zA-Z]+ )+?${query}`\n  }\n  return query\n}\n\nconst TermAggregation = (field: string, size: number, search: string) => {\n  const searchInclude = search && search.length > 0 ? { include: createRegexQuery(search) } : {}\n  return {\n    terms: {\n      field,\n      size,\n      ...searchInclude\n    }\n  }\n}\n\nconst getTermAggregation = (facet: FacetAttribute, size: number, search: string) => {\n  let aggEntries = {}\n  const AggregationFn =\n    typeof facet !== 'string' && facet.facetQuery ? facet.facetQuery : TermAggregation\n\n  const getInnerAggs = (facetName: string, field: string): any => {\n    if (typeof facet === 'string' || facet.type === 'string') {\n      aggEntries = {\n        [facetName]: AggregationFn(field, size, search)\n      }\n    } else if (facet.type === 'numeric') {\n      aggEntries = {\n        [facetName + '$_stats']: {\n          stats: {\n            field: field\n          }\n        },\n        [facetName + '$_entries']: AggregationFn(field, size, search)\n      }\n    }\n    return aggEntries\n  }\n\n  if (typeof facet === 'string') {\n    return getInnerAggs(facet, facet)\n  } else if (isNestedFacet(facet)) {\n    return {\n      [`${facet.nestedPath}.`]: {\n        nested: {\n          path: facet.nestedPath\n        },\n        aggs: getInnerAggs(facet.attribute, `${facet.nestedPath}.${facet.field}`)\n      }\n    }\n  } else {\n    return getInnerAggs(facet.attribute, facet.field)\n  }\n}\n\nexport const getAggs = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions\n) => {\n  const { params = {}, type } = request\n  // @ts-ignore\n  const { facets, maxValuesPerFacet, facetName, facetQuery } = params\n  const maxFacetSize = maxValuesPerFacet || 10\n  const facetAttributes = config.facet_attributes || []\n\n  if (facetName) {\n    const facet = getFacet(facetAttributes, facetName)\n    if (!facet) return null\n    return getTermAggregation(facet, maxFacetSize, facetQuery)\n  } else if (Array.isArray(facets)) {\n    let facetAttibutes = config.facet_attributes || []\n\n    if (queryRuleActions.facetAttributesOrder) {\n      facetAttibutes = queryRuleActions.facetAttributesOrder\n        .map((attribute) => {\n          return getFacet(config.facet_attributes || [], attribute)\n        })\n        .filter((x): x is FacetAttribute => x !== null)\n    }\n\n    const facetAttributes: FacetAttribute[] =\n      facets[0] === '*'\n        ? facetAttibutes\n        : facets\n            .map((facetAttribute) => {\n              return getFacet(config.facet_attributes || [], facetAttribute)\n            })\n            .filter((x): x is FacetAttribute => x !== null)\n\n    return (\n      facetAttributes.reduce((sum, facet) => {\n        return deepmerge(sum, getTermAggregation(facet, maxFacetSize, ''))\n      }, {}) || {}\n    )\n  } else if (typeof facets === 'string') {\n    const field = getFacet(config.facet_attributes || [], facets)\n    if (!field) return {}\n    return getTermAggregation(field, maxFacetSize, '')\n  }\n}\n\nfunction queryRulesWrapper(organicQuery: any, queryRuleActions: QueryRuleActions) {\n  if (queryRuleActions.touched) {\n    return {\n      function_score: {\n        query: {\n          pinned: {\n            ids: queryRuleActions.pinnedDocs,\n            organic: organicQuery\n          }\n        },\n        functions: queryRuleActions.boostFunctions\n      }\n    }\n  }\n  return organicQuery\n}\n\nexport function RelevanceQueryMatch(query: string, search_attributes: SearchAttribute[]) {\n  const getFieldsMap = (boostMultiplier: number) => {\n    return search_attributes.map((attribute) => {\n      return typeof attribute === 'string'\n        ? attribute\n        : `${attribute.field}^${(attribute.weight || 1) * boostMultiplier}`\n    })\n  }\n\n  return {\n    bool: {\n      should: [\n        {\n          bool: {\n            should: [\n              {\n                multi_match: {\n                  query: query,\n                  fields: getFieldsMap(1),\n                  fuzziness: 'AUTO:4,8'\n                }\n              },\n              {\n                multi_match: {\n                  query: query,\n                  fields: getFieldsMap(0.5),\n                  type: 'bool_prefix'\n                }\n              }\n            ]\n          }\n        },\n        {\n          multi_match: {\n            query: query,\n            type: 'phrase',\n            fields: getFieldsMap(2)\n          }\n        }\n      ]\n    }\n  }\n}\n\nconst getQuery = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions,\n  requestOptions?: RequestOptions\n): { query?: QueryDslQueryContainer; knn?: KnnSearchQuery; rank?: RankContainer } => {\n  const query = queryRuleActions.query\n\n  const searchAttributes = config.search_attributes\n\n  const filters = [\n    ...transformFacetFilters(request, config),\n    ...transformNumericFilters(request, config),\n    ...transformBaseFilters(request, config),\n    ...transformGeoFilters(request, config),\n    ...(requestOptions?.getBaseFilters?.() || []),\n    ...queryRuleActions.baseFilters\n  ]\n\n  let organicQuery =\n    typeof query === 'string' && query !== ''\n      ? requestOptions?.getQuery\n        ? requestOptions.getQuery(query, searchAttributes, config)\n        : RelevanceQueryMatch(query, searchAttributes)\n      : {\n          match_all: {}\n        }\n\n  const hasKnn = typeof requestOptions?.getKnnQuery === 'function'\n  const hasNoQuery = requestOptions?.getQuery?.(query, searchAttributes, config) === false\n\n  if (hasNoQuery || (hasKnn && query === '')) {\n    organicQuery = {\n      match_all: {}\n    }\n  }\n\n  const queryDsl = {\n    bool: {\n      filter: filters,\n      must: queryRuleActions.touched\n        ? queryRulesWrapper(organicQuery, queryRuleActions)\n        : organicQuery\n    }\n  }\n\n  let knnQueryDsl: KnnSearchQuery | null = null\n\n  if (hasKnn && query !== '') {\n    knnQueryDsl = {\n      filter: filters,\n      ...(requestOptions?.getKnnQuery?.(query, searchAttributes, config) || {})\n    } as KnnSearchQuery\n  }\n\n  if (query !== '' && hasNoQuery && hasKnn && knnQueryDsl) {\n    return {\n      knn: knnQueryDsl\n    }\n  }\n\n  const size = getHitsPerPage(request)\n\n  return {\n    query: queryDsl,\n    knn: knnQueryDsl ? knnQueryDsl : undefined,\n    // in hybrid mode (knn + keyword query), is displaying results and query is not empty\n    rank:\n      hasKnn && !hasNoQuery && size > 0 && query !== '' ? { rrf: { window_size: size } } : undefined\n  }\n}\n\nconst getHitsPerPage = (request: AlgoliaMultipleQueriesQuery) => {\n  const { params = {} } = request\n  return params.hitsPerPage == null ? 20 : params.hitsPerPage\n}\n\nconst getResultsSize = (request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) => {\n  const { params = {} } = request\n  const hitsPerPage = getHitsPerPage(request)\n\n  return {\n    size: hitsPerPage,\n    from: (params.page || 0) * hitsPerPage\n  }\n}\n\nexport const getHitFields = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { attributesToRetrieve } = params\n  // ignoring attributesToRetrieve for now\n\n  const sourceFields = new Set([\n    ...(config.result_attributes || []),\n    ...(config.highlight_attributes || []),\n    ...(config.geo_attribute ? [config.geo_attribute] : [])\n  ])\n\n  const runtimeFields = Object.keys(config.runtime_mappings || {})\n  const fields = runtimeFields.reduce<string[]>((sum, field) => {\n    if (config.result_attributes?.includes(field)) {\n      return [field, ...sum]\n    }\n    return sum\n  }, [])\n\n  return {\n    _source: {\n      includes: Array.from(sourceFields)\n    },\n    ...(fields.length > 0 ? { fields } : {})\n  }\n}\n\nexport const getSnippetFieldLength = (attribute: string) => {\n  const defaultMatch = {\n    attribute,\n    length: 100\n  }\n  if (!attribute.includes(':')) {\n    return defaultMatch\n  }\n  const match = attribute.match(/(.+)\\:(\\d+)/)\n  if (!match) return defaultMatch\n  return {\n    attribute: match[1],\n    length: parseInt(match[2])\n  }\n}\n\nexport const getHighlightFields = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { attributesToHighlight } = params\n  // ignoring attributesToHighlight for now\n\n  const highlightFields =\n    config.highlight_attributes?.reduce(\n      (sum, field) => ({\n        ...sum,\n        [field]: {\n          number_of_fragments: 0\n        }\n      }),\n      {}\n    ) || {}\n\n  const snippetFields =\n    config.snippet_attributes?.reduce(\n      (sum, attribute) => ({\n        ...sum,\n        [getSnippetFieldLength(attribute).attribute]: {\n          number_of_fragments: 5,\n          fragment_size: getSnippetFieldLength(attribute).length\n        }\n      }),\n      {}\n    ) || {}\n\n  if (Object.keys(highlightFields).length === 0 && Object.keys(snippetFields).length === 0) {\n    return {}\n  }\n\n  return {\n    highlight: {\n      pre_tags: ['<em>'],\n      post_tags: ['</em>'],\n      fields: {\n        ...highlightFields,\n        ...snippetFields\n      }\n    }\n  }\n}\n\nconst getRuntimeMappings = (request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) => {\n  if (!config.runtime_mappings) {\n    return {}\n  }\n\n  return {\n    runtime_mappings: config.runtime_mappings\n  }\n}\n\nexport function transformRequest(\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions,\n  requestOptions?: RequestOptions\n): ElasticsearchSearchRequest {\n  const body: ElasticsearchSearchRequest = {\n    aggs: getAggs(request, config, queryRuleActions),\n    ...getQuery(request, config, queryRuleActions, requestOptions),\n    ...getResultsSize(request, config),\n    ...getHitFields(request, config),\n    ...getHighlightFields(request, config),\n    ...getSorting(request, config),\n    ...getRuntimeMappings(request, config)\n  }\n\n  return body\n}\n","export const TermFilter = (field: string, value: string) => {\n  return { term: { [field]: value } }\n}\n\nexport const MatchFilter = (field: string, value: string) => {\n  return { match: { [field]: value } }\n}\n","import { FacetAttribute, FacetFieldConfig, SearchRequest } from './types'\n\nexport const createRegexQuery = (queryString: string) => {\n  let query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n  query = query\n    .split('')\n    .map((char) => {\n      if (/[a-z]/.test(char)) {\n        return `[${char}${char.toUpperCase()}]`\n      }\n      return char\n    })\n    .join('')\n  query = `${query}.*`\n  if (queryString.length > 2) {\n    query = `([a-zA-Z]+ )+?${query}`\n  }\n  return query\n}\n\nexport const getFacet = (\n  facet_attributes: FacetAttribute[],\n  attributeName: string\n): FacetAttribute | null => {\n  const f = facet_attributes.find((a) => {\n    if (typeof a === 'string') {\n      return a === attributeName\n    }\n    return a.attribute === attributeName\n  })\n  return f || null\n}\n\nexport const isNestedFacet = (facet: FacetAttribute): boolean => {\n  return typeof facet !== 'string' && !!facet.nestedPath\n}\n\nexport const getFacetField = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): string => {\n  const attributeKey = typeof attribute === 'string' ? attribute : attribute.attribute\n\n  if (facet_attributes.includes(attributeKey)) {\n    return attributeKey\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a.attribute === attributeKey)?.field || attributeKey\n  )\n}\n\nexport const getFacetByAttribute = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): string => {\n  const attributeKey = getFacetAttribute(attribute)\n\n  if (facet_attributes.includes(attributeKey)) {\n    return attributeKey\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a.attribute === attributeKey)?.attribute || attributeKey\n  )\n}\n\nexport const getFacetAttribute = (facetAttribute: FacetAttribute): string => {\n  return typeof facetAttribute === 'string' ? facetAttribute : facetAttribute.attribute\n}\n\nexport const getFacetFieldType = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): FacetFieldConfig['type'] => {\n  const attributeKey = typeof attribute === 'string' ? attribute : attribute.attribute\n\n  if (facet_attributes.includes(attributeKey)) {\n    return 'string'\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a?.attribute === attributeKey)?.type || 'string'\n  )\n}\n\nexport const createElasticsearchQueryFromRequest = (requests: SearchRequest[]) => {\n  return requests\n    .reduce<string[]>(\n      (sum, request) => [\n        ...sum,\n        JSON.stringify({ index: request.indexName }),\n        '\\n',\n        JSON.stringify(request.body),\n        '\\n'\n      ],\n      []\n    )\n    .join('')\n}\n","import { MatchFilter, TermFilter } from './filterUtils'\nimport type {\n  AlgoliaMultipleQueriesQuery,\n  FacetAttribute,\n  SearchSettingsConfig,\n  ElasticsearchQuery,\n  FilterAttribute,\n  FacetFieldConfig\n} from './types'\nimport { getFacet, getFacetAttribute, isNestedFacet } from './utils'\n\nexport const transformNumericFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n): ElasticsearchQuery[] => {\n  const { params = {} } = request\n  const { numericFilters } = params\n\n  if (!Array.isArray(numericFilters)) {\n    return []\n  }\n\n  return numericFilters.reduce((sum, filter: string) => {\n    let match, field, operator, value, maxValue = ''\n    let groups = filter.match(\n      /([\\w\\.\\_\\-]+)\\s*(\\=|\\!\\=|\\>|\\>\\=|\\<|\\<\\=)\\s*(-?\\d+)/\n    )\n\n    if (groups) {\n      [match, field, operator, value] = groups\n    }\n    else {\n      // Alternative syntax: 'attribute:lower_value TO higher_value'\n      groups = filter.match(\n        /([\\w\\.\\_\\-]+):\\s*(-?\\d+)\\s*([Tt][Oo])\\s*(-?\\d+)/\n      )\n\n      if (!groups) {\n        throw new Error(\n          `Numeric filter \"${filter}\" could not be parsed. It should either be in the format \"attributeName operator operand\" or \"attributeName: lowerBound TO upperBound\"`\n        );\n      }\n\n      [match, field, value, operator, maxValue] = groups\n    }\n\n    const facetFilterMap = getFacetFilterMap(\n      config.facet_attributes || [],\n      config.filter_attributes || []\n    )\n    const facetFilterConfig = facetFilterMap[field]\n\n    const getFilter = (field: string, operator: string, value: string) => {\n      if (operator === '=') {\n        return {\n          term: {\n            [field]: value\n          }\n        }\n      } else if (operator === '!=') {\n        return {\n          bool: {\n            must_not: {\n              term: {\n                [field]: value\n              }\n            }\n          }\n        }\n      } else if (operator === '>') {\n        return {\n          range: {\n            [field]: {\n              gt: value\n            }\n          }\n        }\n      } else if (operator === '>=') {\n        return {\n          range: {\n            [field]: {\n              gte: value\n            }\n          }\n        }\n      } else if (operator === '<') {\n        return {\n          range: {\n            [field]: {\n              lt: value\n            }\n          }\n        }\n      } else if (operator === '<=') {\n        return {\n          range: {\n            [field]: {\n              lte: value\n            }\n          }\n        }\n      } else if (operator.toUpperCase() === 'TO') {\n        return {\n          range: {\n            [field]: {\n              gte: value,\n              lte: maxValue,\n            }\n          }\n        }\n      }\n    }\n\n    const esFilter = []\n\n    if (facetFilterConfig.nestedPath) {\n      const nestedPathPresent = sum.find((filter: any) => {\n        return filter.nested.path === facetFilterConfig.nestedPath\n      })\n\n      if (nestedPathPresent) {\n        nestedPathPresent.nested.query.bool.filter.push(\n          getFilter(facetFilterConfig.nestedPath + '.' + facetFilterConfig.field, operator, value)\n        )\n      } else {\n        esFilter.push({\n          nested: {\n            path: facetFilterConfig.nestedPath,\n            inner_hits: {},\n            query: {\n              bool: {\n                filter: [\n                  getFilter(\n                    facetFilterConfig.nestedPath + '.' + facetFilterConfig.field,\n                    operator,\n                    value\n                  )\n                ]\n              }\n            }\n          }\n        })\n      }\n    } else {\n      esFilter.push(getFilter(facetFilterConfig.field, operator, value))\n    }\n\n    return [...sum, ...esFilter]\n  }, [])\n}\n\nconst getFacetFilterMap = (facets: FacetAttribute[], filters: FilterAttribute[]) => {\n  return [...filters, ...facets].reduce<Record<string, FacetFieldConfig | FilterAttribute>>(\n    (sum, filter) => {\n      let f: FacetFieldConfig | FilterAttribute =\n        typeof filter === 'string' ? { attribute: filter, field: filter, type: 'string' } : filter\n\n      return {\n        ...sum,\n        [f.attribute]: f\n      }\n    },\n    {}\n  )\n}\n\nexport const transformFacetFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n): ElasticsearchQuery[] => {\n  const { params = {} } = request\n  const { facetFilters } = params\n\n  if (!Array.isArray(facetFilters)) {\n    return []\n  }\n\n  const facetFilterMap = getFacetFilterMap(\n    config.facet_attributes || [],\n    config.filter_attributes || []\n  )\n\n  return facetFilters.reduce((sum, filter) => {\n    if (Array.isArray(filter)) {\n      return [\n        ...sum,\n        {\n          bool: {\n            should: filter.reduce((sum, filter) => {\n              const [facet, value] = filter.split(':')\n              const facetFilterConfig = facetFilterMap[facet]\n              if (!facetFilterConfig)\n                throw new Error(\n                  `Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`\n                )\n              const field = facetFilterConfig.field\n              const filterClauseFn = facetFilterConfig.filterQuery || TermFilter\n\n              if (isNestedFacet(facetFilterConfig)) {\n                // detect if there is a nested filter in sum\n                // if one doesn't exist, add one\n                // if one does exist, add to it\n                const nestedFilter = sum.find((filter: any) => {\n                  return filter.nested && filter.nested.path === facetFilterConfig.nestedPath\n                })\n\n                if (nestedFilter) {\n                  nestedFilter.nested.query.bool.should.push(\n                    filterClauseFn(\n                      `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                      value\n                    )\n                  )\n                  return sum\n                } else {\n                  return [\n                    ...sum,\n                    {\n                      nested: {\n                        inner_hits: {},\n                        path: facetFilterConfig.nestedPath,\n                        query: {\n                          bool: {\n                            should: [\n                              filterClauseFn(\n                                `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                                value\n                              )\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n              return [...sum, filterClauseFn(field, value)]\n            }, [])\n          }\n        }\n      ]\n    } else if (typeof filter === 'string') {\n      const [facet, value] = filter.split(':')\n\n      const facetFilterConfig = facetFilterMap[facet]\n      if (!facetFilterConfig)\n        throw new Error(\n          `Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`\n        )\n\n      const filterClauseFn = facetFilterConfig.filterQuery || TermFilter\n\n      if (isNestedFacet(facetFilterConfig) && facetFilterConfig.nestedPath) {\n        // detect if there is a nested filter in sum\n        // if one doesn't exist, add one\n        // if one does exist, add to it\n        const nestedFilter = sum.find((filter: any) => {\n          return filter.nested && filter.nested.path === facetFilterConfig.nestedPath + '.'\n        })\n\n        if (nestedFilter) {\n          nestedFilter.nested.query.bool.should.push(\n            filterClauseFn(`${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`, value)\n          )\n          return sum\n        } else {\n          return [\n            ...sum,\n            {\n              nested: {\n                inner_hits: {},\n                path: facetFilterConfig.nestedPath,\n                query: {\n                  bool: {\n                    should: [\n                      filterClauseFn(\n                        `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                        value\n                      )\n                    ]\n                  }\n                }\n              }\n            }\n          ]\n        }\n      }\n      return [...sum, filterClauseFn(facetFilterConfig.field, value)]\n    }\n  }, [])\n}\n\nexport const transformQueryString = (\n  facets: FacetAttribute[] = [],\n  filters: FilterAttribute[] = [],\n  queryString: string\n) => {\n  const regex = /([\\w\\.\\-]+)\\:/gi\n  const filterMap = getFacetFilterMap(facets, filters)\n  return queryString.replace(regex, (match: string, word: string) => {\n    if (!filterMap[word]) {\n      throw new Error(\n        `Attribute \"${word}\" is not defined as an attribute in the facet or filter search settings`\n      )\n    }\n\n    if (!!filterMap[word].nestedPath) {\n      throw new Error(\n        `Attribute \"${word}\" is a nested field and cannot be used as a filter. Nested fields are supported in facetFilers or numericFilters.`\n      )\n    }\n\n    return filterMap[word].field + ':'\n  })\n}\n\nexport const transformBaseFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { filters } = params\n\n  if (!filters || filters === '') {\n    return []\n  }\n\n  const queryString = transformQueryString(\n    config.facet_attributes,\n    config.filter_attributes,\n    filters\n  )\n\n  return [\n    {\n      query_string: {\n        query: queryString\n      }\n    }\n  ]\n}\n\nexport const transformGeoFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  if (!config.geo_attribute) {\n    return []\n  }\n  const { params = {} } = request\n  const { aroundLatLng, aroundRadius, insideBoundingBox } = params\n\n  if (insideBoundingBox) {\n    return [insideBoundingBoxFilter(insideBoundingBox, config.geo_attribute)]\n  }\n\n  if (aroundLatLng) {\n    const geoPoint = aroundLatLng.split(',')\n\n    return [\n      {\n        geo_distance: {\n          distance: aroundRadius || '1000m',\n          [config.geo_attribute]: {\n            lat: geoPoint[0],\n            lon: geoPoint[1]\n          }\n        }\n      }\n    ]\n  }\n\n  return []\n}\n\nfunction insideBoundingBoxFilter(\n  insideBoundingBox: string | readonly (readonly number[])[],\n  field: string\n) {\n  const geoBoundingboxFilter = (top: number, left: number, bottom: number, right: number) => {\n    return {\n      geo_bounding_box: {\n        [field]: {\n          top_right: {\n            lat: top,\n            lon: left\n          },\n          bottom_left: {\n            lat: bottom,\n            lon: right\n          }\n        }\n      }\n    }\n  }\n\n  if (typeof insideBoundingBox === 'string') {\n    const [top, left, bottom, right] = insideBoundingBox.split(',')\n    return geoBoundingboxFilter(\n      parseFloat(top),\n      parseFloat(left),\n      parseFloat(bottom),\n      parseFloat(right)\n    )\n  } else if (Array.isArray(insideBoundingBox)) {\n    const geoBoundingboxes = insideBoundingBox.map((boundingBox) => {\n      const [top, left, bottom, right] = boundingBox\n      return geoBoundingboxFilter(\n        parseFloat(top),\n        parseFloat(left),\n        parseFloat(bottom),\n        parseFloat(right)\n      )\n    })\n\n    return {\n      bool: {\n        should: geoBoundingboxes\n      }\n    }\n  }\n}\n","import { SearchSettingsConfig } from './types'\nimport { AlgoliaMultipleQueriesQuery } from './types'\n\nexport function getSorting(request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find((key) => {\n      if (request.indexName.endsWith(key)) {\n        return true\n      }\n    })\n\n    if (!selectedSorting && !config.sorting.default) return {}\n\n    const sortOption = selectedSorting ? config.sorting[selectedSorting] : config.sorting.default\n\n    if (Array.isArray(sortOption)) {\n      return {\n        sort: sortOption.map((sorting) => {\n          return {\n            [sorting.field]: sorting.order\n          }\n        })\n      }\n    } else {\n      return {\n        sort: {\n          [sortOption.field]: sortOption.order\n        }\n      }\n    }\n  }\n  return {}\n}\n\nexport function getIndexName(indexName: string, config: SearchSettingsConfig) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find((key) => {\n      if (indexName.endsWith(key)) {\n        return true\n      }\n    })\n\n    if (selectedSorting) {\n      return indexName.replace(selectedSorting, '')\n    }\n  }\n  return indexName\n}\n","import { getSnippetFieldLength } from './transformRequest'\nimport type { ElasticsearchHit, SearchSettingsConfig } from './types'\n\nexport function highlightTerm(value: string, query: string): string {\n  const regex = new RegExp(query, 'gi')\n  return value.replace(regex, (match) => `<em>${match}</em>`)\n}\n\nexport function isAllowableHighlightField(\n  fieldKey: string,\n  highlightFields: string[]\n) {\n  return highlightFields.findIndex((highlightField) => {\n    if (highlightField.indexOf('*') < 0) {\n      return highlightField === fieldKey;\n    }\n\n    const safeHighlightField = highlightField.replace(/[.+?^$|\\{\\}\\(\\)\\[\\]\\\\]/g, '\\\\$&');\n    const regex = new RegExp(`^${safeHighlightField.replace(/\\*/g, '.*')}$`);\n    return regex.test(fieldKey);\n  }) >= 0;\n}\n\nexport function getHighlightFields(\n  hit: ElasticsearchHit,\n  preTag: string = '<ais-highlight-0000000000>',\n  postTag: string = '<ais-highlight-0000000000/>',\n  fields: SearchSettingsConfig['snippet_attributes'] = []\n) {\n  const { _source = {}, highlight = {} } = hit\n\n  const combinedKeys = {\n    ..._source,\n    ...highlight\n  }\n\n  const highlightFields = fields.map((field) => getSnippetFieldLength(field).attribute)\n\n  const hitHighlights = Object.keys(combinedKeys).reduce<Record<string, any>>((sum, fieldKey) => {\n    const fieldValue: any = _source[fieldKey]\n    const highlightedMatch = highlight[fieldKey] || null\n\n    if (!isAllowableHighlightField(fieldKey, highlightFields)) {\n      return sum\n    }\n    // no matches, specified as a highlight and value is an array\n    if (Array.isArray(fieldValue) && !highlightedMatch) {\n      return {\n        ...sum,\n        [fieldKey]: fieldValue.map((value) => ({\n          matchLevel: 'none',\n          matchedWords: [],\n          value: value.toString()\n        }))\n      }\n      // field array and has multiple highlighted matches\n    } else if (Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) {\n      return {\n        ...sum,\n        [fieldKey]: highlightedMatch.map((highlightedMatch) => {\n          const matchWords = Array.from(highlightedMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(\n            (match) => match[1]\n          )\n          return {\n            fullyHighlighted: false,\n            matchLevel: 'full',\n            matchedWords: matchWords,\n            value: highlightedMatch\n              .toString()\n              .replace(/\\<em\\>/g, preTag)\n              .replace(/\\<\\/em\\>/g, postTag)\n          }\n        })\n      }\n    } else if (\n      (!Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) ||\n      (!fieldValue && Array.isArray(highlightedMatch) && highlightedMatch.length > 0)\n    ) {\n      const singleMatch = highlightedMatch[0]\n\n      const matchWords = Array.from(singleMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(\n        (match) => match[1]\n      )\n      const x = {\n        fullyHighlighted: false,\n        matchLevel: 'full',\n        matchedWords: matchWords,\n        value: singleMatch\n          .toString()\n          .replace(/\\<em\\>/g, preTag)\n          .replace(/\\<\\/em\\>/g, postTag)\n      }\n\n      return {\n        ...sum,\n        [fieldKey]: x\n      }\n    }\n\n    return {\n      ...sum,\n      [fieldKey]: {\n        matchLevel: 'none',\n        matchedWords: [],\n        value: fieldValue != undefined ? fieldValue.toString() : ''\n      }\n    }\n  }, {})\n\n  return hitHighlights\n}\n","import { SearchSettingsConfig } from './types'\nimport { getHighlightFields, highlightTerm } from './highlightUtils'\nimport { AlgoliaMultipleQueriesQuery, ElasticsearchResponseBody } from './types'\nimport { getFacetFieldType } from './utils'\nimport { QueryRuleActions } from './queryRules'\nimport type { AggregationsStatsAggregate, GeoLocation } from '@elastic/elasticsearch/lib/api/types'\n\ntype FacetsList = Record<string, Record<string, number>>\ntype FacetsStats = Record<\n  string,\n  { min: number | null; max: number | null; avg: number | null; sum: number | null }\n>\n\nconst getHits = (\n  response: ElasticsearchResponseBody,\n  config: SearchSettingsConfig,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery\n) => {\n  const { hits } = response\n  const { highlight_attributes = [], snippet_attributes = [] } = config\n\n  return hits.hits.map((hit) => ({\n    objectID: hit._id,\n    _index: hit?._index,\n    ...(hit._source || {}),\n    ...(hit.fields || {}), // for runtime_mapping fields\n    ...(hit.inner_hits ? { inner_hits: hit.inner_hits } : {}),\n    ...(highlight_attributes.length > 0\n      ? {\n          _highlightResult: getHighlightFields(\n            hit,\n            instantsearchRequest?.params?.highlightPreTag,\n            instantsearchRequest?.params?.highlightPostTag,\n            highlight_attributes\n          )\n        }\n      : {}),\n    ...(snippet_attributes.length > 0\n      ? {\n          _snippetResult: getHighlightFields(\n            hit,\n            instantsearchRequest?.params?.highlightPreTag,\n            instantsearchRequest?.params?.highlightPostTag,\n            config.snippet_attributes\n          )\n        }\n      : {}),\n    ...(config.geo_attribute && hit._source?.[config.geo_attribute]\n      ? { _geoloc: convertLatLng(hit._source?.[config.geo_attribute] as GeoLocation) }\n      : {})\n  }))\n}\n\nfunction convertLatLng(value: GeoLocation) {\n  if (typeof value === 'string') {\n    const [lat, lng] = value.split(',').map((v) => parseFloat(v))\n    return { lat, lng }\n  } else if (Array.isArray(value)) {\n    return { lat: value[0], lng: value[1] }\n  } else if (typeof value === 'object') {\n    if ('lat' in value && 'lon' in value) {\n      return {\n        lat: parseFloat(value.lat as unknown as string),\n        lng: parseFloat(value.lon as unknown as string)\n      }\n    }\n  }\n  return null\n}\n\nconst getFacets = (response: ElasticsearchResponseBody, config: SearchSettingsConfig) => {\n  if (!response?.aggregations) {\n    return {}\n  }\n\n  // flattening for nested facets\n  const aggregations = Object.keys(response.aggregations).reduce<Record<string, any>>(\n    (sum, key) => {\n      const value = (response.aggregations || {})[key] as any\n\n      if (key.endsWith('.')) {\n        const { doc_count, ...nestedAggregations } = value\n        return {\n          ...sum,\n          ...nestedAggregations\n        }\n      }\n\n      return {\n        ...sum,\n        [key]: value\n      }\n    },\n    {}\n  )\n\n  return Object.keys(aggregations).reduce<{\n    facets: FacetsList\n    facets_stats: FacetsStats\n  }>(\n    (sum, f) => {\n      const facet = f.split('$')[0]\n      const fieldType = getFacetFieldType(config.facet_attributes || [], facet)\n\n      if (fieldType === 'numeric') {\n        const facetValues = aggregations[facet + '$_stats'] as AggregationsStatsAggregate\n        const { buckets } = aggregations[facet + '$_entries'] as {\n          buckets: any[]\n        }\n\n        return {\n          ...sum,\n          facets: {\n            ...sum.facets,\n            [facet]: buckets.reduce<Record<string, number>>(\n              (sum, bucket) => ({\n                ...sum,\n                [bucket.key]: bucket.doc_count\n              }),\n              {}\n            )\n          },\n          facets_stats: {\n            ...sum.facets_stats,\n            [facet]: {\n              min: facetValues.min,\n              avg: facetValues.avg,\n              max: facetValues.max,\n              sum: facetValues.sum\n            }\n          }\n        }\n      }\n\n      const { buckets } = aggregations[facet] as { buckets: any[] }\n\n      return {\n        ...sum,\n        facets: {\n          ...sum.facets,\n          [facet]: buckets.reduce<Record<string, number>>(\n            (sum, bucket) => ({\n              ...sum,\n              [bucket.key]: bucket.doc_count\n            }),\n            {}\n          )\n        }\n      }\n    },\n    {\n      facets: {},\n      facets_stats: {}\n    }\n  )\n}\n\nconst getRenderingContent = (config: SearchSettingsConfig, queryRuleActions: QueryRuleActions) => {\n  const defaultOrder = config.facet_attributes?.map((facet) =>\n    typeof facet === 'string' ? facet : facet.attribute\n  )\n\n  return {\n    renderingContent: {\n      facetOrdering: {\n        facets: {\n          order: queryRuleActions.facetAttributesOrder || defaultOrder || []\n        },\n        values: config.facet_attributes?.reduce<Record<string, { sortRemainingBy: 'count' }>>(\n          (sum, facet) => {\n            const facetName = typeof facet === 'string' ? facet : facet.attribute\n\n            // If request has explicit facet orders and the facet is not\n            // in the query rule actions, we don't want to sort it\n            if (\n              queryRuleActions.facetAttributesOrder &&\n              !queryRuleActions.facetAttributesOrder.includes(facetName)\n            ) {\n              return sum\n            }\n\n            return {\n              ...sum,\n              [facetName]: {\n                sortRemainingBy: 'count'\n              }\n            }\n          },\n          {}\n        )\n      }\n    }\n  }\n}\n\nconst getPageDetails = (\n  response: ElasticsearchResponseBody,\n  request: AlgoliaMultipleQueriesQuery,\n  queryRuleActions: QueryRuleActions\n) => {\n  const { params = {} } = request\n  const { hitsPerPage = 20, page = 0 } = params\n\n  const { total } = response.hits\n  const totalHits = typeof total === 'number' ? total : total?.value\n  const nbPages =\n    hitsPerPage <= 0\n      ? 0\n      : Math.ceil((typeof total === 'number' ? total : total?.value || 0) / hitsPerPage)\n\n  return {\n    hitsPerPage,\n    processingTimeMS: response.took,\n    nbHits: totalHits,\n    page: page,\n    nbPages,\n    query: queryRuleActions.query\n  }\n}\n\nexport default function transformResponse(\n  response: ElasticsearchResponseBody,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions\n) {\n  try {\n    return {\n      appliedRules: queryRuleActions.ruleIds,\n      exhaustiveNbHits: true,\n      exhaustiveFacetsCount: true,\n      exhaustiveTypo: true,\n      exhaustive: { facetsCount: true, nbHits: true, typo: true },\n      ...getPageDetails(response, instantsearchRequest, queryRuleActions),\n      ...getRenderingContent(config, queryRuleActions),\n      ...getFacets(response, config),\n      hits: getHits(response, config, instantsearchRequest),\n      index: instantsearchRequest.indexName,\n      params: new URLSearchParams(instantsearchRequest.params as any).toString(),\n      ...(queryRuleActions.userData.length > 0 ? { userData: queryRuleActions.userData } : {})\n    }\n  } catch (e) {\n    throw new Error(`Error transforming Elasticsearch response for index`)\n  }\n}\n\nexport const transformFacetValuesResponse = (\n  response: ElasticsearchResponseBody,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery\n) => {\n  const aggregations = response.aggregations || {}\n  // @ts-ignore\n  const facetName = instantsearchRequest?.params?.facetName\n\n  const preTag = instantsearchRequest.params?.highlightPreTag || '<ais-highlight-0000000000>'\n  const postTag = instantsearchRequest.params?.highlightPostTag || '<ais-highlight-0000000000/>'\n\n  let agg = aggregations[Object.keys(aggregations)[0]] as any\n\n  if (agg && agg[facetName]) {\n    agg = agg[facetName]\n  }\n\n  return {\n    facetHits: agg.buckets.map((entry: any) => ({\n      value: entry.key,\n      highlighted: highlightTerm(\n        entry.key,\n        // @ts-ignore\n        instantsearchRequest.params.facetQuery || ''\n      )\n        .replace(/<\\em>/g, preTag)\n        .replace(/<\\/\\em>/g, postTag),\n      count: entry.doc_count\n    })),\n    exhaustiveFacetsCount: true,\n    processingTimeMS: response.took\n  }\n}\n","import { AppSettings, BasicAuth, ConfigConnection, SearchRequest } from './types'\nimport { ElasticsearchResponseBody, Transporter } from './types'\nimport { createElasticsearchQueryFromRequest } from './utils'\n\nconst authString = (auth: BasicAuth) => {\n  if (typeof btoa === 'undefined') {\n    return Buffer.from(auth.username + ':' + auth.password).toString('base64')\n  } else {\n    return btoa(auth.username + ':' + auth.password)\n  }\n}\n\nfunction getHostFromCloud(cloudId: string) {\n  // the cloud id is `cluster-name:base64encodedurl`\n  // the url is a string divided by two '$', the first is the cloud url\n  // the second the elasticsearch instance, the third the kibana instance\n  let cloudUrls\n  if (typeof atob === 'undefined') {\n    cloudUrls = Buffer.from(cloudId.split(':')[1], 'base64').toString()\n  } else {\n    cloudUrls = atob(cloudId.split(':')[1]).split('$')\n  }\n  return `https://${cloudUrls[1]}.${cloudUrls[0]}`\n}\n\nexport class ESTransporter implements Transporter {\n  constructor(public config: ConfigConnection, private settings: AppSettings) {}\n\n  createElasticsearchQueryFromRequest(requests: SearchRequest[]) {\n    return createElasticsearchQueryFromRequest(requests)\n  }\n\n  async performNetworkRequest(requests: SearchRequest[]) {\n    if (this.config.host === undefined && this.config.cloud_id === undefined) {\n      throw new Error(\n        'No Elasticsearch host or cloud_id specified. Please provide a host or cloud id in your Searchkit configuration.'\n      )\n    }\n\n    const host = this.config.cloud_id ? getHostFromCloud(this.config.cloud_id) : this.config.host\n\n    return fetch(`${host}/_msearch`, {\n      headers: {\n        ...(this.config.apiKey ? { authorization: `ApiKey ${this.config.apiKey}` } : {}),\n        'content-type': 'application/json',\n        ...(this.config.headers || {}),\n        ...(this.config.auth\n          ? {\n              Authorization: 'Basic ' + authString(this.config.auth)\n            }\n          : {})\n      },\n      body: this.createElasticsearchQueryFromRequest(requests),\n      method: 'POST'\n    })\n  }\n\n  async msearch(requests: SearchRequest[]): Promise<ElasticsearchResponseBody[]> {\n    try {\n      const response = await this.performNetworkRequest(requests)\n      const responses = await response.json()\n\n      if (this.settings.debug) {\n        console.log('Elasticsearch response:')\n        console.log(JSON.stringify(responses))\n      }\n\n      if (responses.status >= 500) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Elasticsearch Internal Error: Check your elasticsearch instance to make sure it can recieve requests.'\n        )\n      } else if (responses.status === 401) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Cannot connect to Elasticsearch. Check your connection host and auth details (username/password or API Key required). You can also provide a custom Elasticsearch transporter to the API Client. See https://www.searchkit.co/docs/guides/setup-elasticsearch#connecting-with-usernamepassword for more details.'\n        )\n      } else if (responses.responses?.[0]?.status === 403) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Auth Error: You do not have permission to access this index. Check you are calling the right index (specified in frontend) and your API Key permissions has access to the index.'\n        )\n      } else if (responses.status === 404 || responses.responses?.[0]?.status === 404) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Elasticsearch index not found. Check your index name and make sure it exists.'\n        )\n      } else if (responses.status === 400 || responses.responses?.[0]?.status === 400) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          `Elasticsearch Bad Request. \n          \n          1. Check your query and make sure it is valid. \n          2. Check the field mapping. See documentation to make sure you are using text types for searching and keyword fields for faceting\n          3. Turn on debug mode to see the Elasticsearch query and the error response.\n          `\n        )\n      }\n      return responses.responses\n    } catch (error) {\n      throw error\n    }\n  }\n}\n","import { transformQueryString } from './filters'\nimport { AlgoliaMultipleQueriesQuery, QueryRule, SearchSettingsConfig } from './types'\n\nexport interface QueryContextFilter {\n  attribute: string\n  value: string\n}\n\nexport interface QueryContext {\n  query: string\n  context: readonly string[]\n  filters: readonly QueryContextFilter[]\n}\n\nexport interface QueryRuleActions {\n  ruleIds: string[]\n  pinnedDocs: string[]\n  boostFunctions: any[]\n  query: string\n  userData: unknown[]\n  facetAttributesOrder: string[] | undefined\n  baseFilters: any[]\n  touched: boolean\n}\n\nconst getFacetFilters = (\n  facetFilters: string | readonly string[] | readonly (string | readonly string[])[] | undefined\n): QueryContextFilter[] => {\n  if (!facetFilters) {\n    return []\n  }\n  if (typeof facetFilters === 'string') {\n    const [attribute, value] = facetFilters.split(':')\n    return [{ attribute, value }]\n  } else {\n    // @ts-ignore\n    return facetFilters.reduce<QueryContextFilter[]>((sum: any, filter: any) => {\n      if (typeof filter === 'string') {\n        const [attribute, value] = filter.split(':')\n        return [...sum, { attribute, value }]\n      }\n      return [...sum, ...getFacetFilters(filter)]\n    }, [])\n  }\n}\n\nexport const getQueryRulesActionsFromRequest = (\n  queryRules: QueryRule[],\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const queryContext: QueryContext = {\n    query: request.params?.query || '',\n    context: request.params?.ruleContexts || [],\n    filters: getFacetFilters(request.params?.facetFilters)\n  }\n\n  const satisfiedRules = getSatisfiedRules(queryContext, queryRules || [])\n\n  const actions = satisfiedRules.reduce<QueryRuleActions>(\n    (sum, rule) => {\n      rule.actions.map((action) => {\n        sum.touched = true\n        if (action.action === 'PinnedResult') {\n          sum.pinnedDocs.push(...action.documentIds)\n        } else if (action.action === 'QueryRewrite') {\n          sum.query = action.query\n        } else if (action.action === 'QueryBoost') {\n          sum.boostFunctions.push({\n            filter: {\n              query_string: {\n                query: transformQueryString(\n                  config.facet_attributes,\n                  config.filter_attributes,\n                  action.query\n                )\n              }\n            },\n            weight: action.weight\n          })\n        } else if (action.action === 'RenderUserData') {\n          sum.userData.push(JSON.parse(action.userData))\n        } else if (action.action === 'RenderFacetsOrder') {\n          sum.facetAttributesOrder = action.facetAttributesOrder\n        } else if (action.action === 'QueryFilter') {\n          sum.baseFilters.push({\n            query_string: {\n              query: transformQueryString(\n                config.facet_attributes,\n                config.filter_attributes,\n                action.query\n              )\n            }\n          })\n        }\n      })\n      return sum\n    },\n    {\n      ruleIds: satisfiedRules.map((rule) => rule.id),\n      pinnedDocs: [],\n      boostFunctions: [],\n      query: queryContext.query,\n      userData: [],\n      facetAttributesOrder: undefined,\n      touched: false,\n      baseFilters: []\n    }\n  )\n\n  return actions\n}\n\nexport const getSatisfiedRules = (queryContext: QueryContext, rules: QueryRule[]) =>\n  rules.filter(\n    (ruleOrs) =>\n      ruleOrs.conditions.find(\n        (rule) =>\n          rule.filter((condition) => {\n            if (condition.context === 'query' && condition.match_type === 'exact') {\n              return condition.value === queryContext.query\n            }\n            if (condition.context === 'query' && condition.match_type === 'contains') {\n              return queryContext.query.includes(condition.value)\n            }\n            if (condition.context === 'query' && condition.match_type === 'prefix') {\n              return queryContext.query.startsWith(condition.value)\n            }\n            if (condition.context === 'context') {\n              return condition.value.some((value) => queryContext.context.includes(value))\n            }\n            if (condition.context === 'filterPresent') {\n              return condition.values.every(\n                (value) =>\n                  queryContext.filters.find(\n                    (filter) => filter.attribute === value.attribute && filter.value === value.value\n                  ) !== undefined\n              )\n            }\n\n            return false\n          }).length === rule.length\n      ) !== undefined\n  )\n","import type { MultipleQueriesQuery as AlgoliaMultipleQueriesQuery } from '@algolia/client-search'\nimport { transformRequest } from './transformRequest'\nimport transformResponse, { transformFacetValuesResponse } from './transformResponse'\nimport { SearchkitConfig, SearchRequest, RequestOptions, Transporter, AppSettings } from './types'\nimport { ESTransporter } from './Transporter'\nimport { getQueryRulesActionsFromRequest, QueryRuleActions } from './queryRules'\nimport { createElasticsearchQueryFromRequest } from './utils'\nimport { getIndexName } from './sorting'\nexport * from './types'\nexport * from './Transporter'\nexport * from './filterUtils'\n\nexport default class Searchkit {\n  private transporter: Transporter\n\n  constructor(private config: SearchkitConfig, private settings: AppSettings = { debug: false }) {\n    this.transporter =\n      'msearch' in config.connection\n        ? config.connection\n        : new ESTransporter(config.connection, settings)\n  }\n\n  private async performSearch(requests: SearchRequest[]) {\n    try {\n      if (this.settings.debug) {\n        console.log('Performing search with requests:')\n        console.log('POST /_msearch')\n        console.log(createElasticsearchQueryFromRequest(requests))\n      }\n      const responses = await this.transporter.msearch(requests)\n      return responses\n    } catch (err) {\n      console.error(err)\n      return []\n    }\n  }\n\n  async handleInstantSearchRequests(\n    instantsearchRequests: readonly AlgoliaMultipleQueriesQuery[],\n    requestOptions?: RequestOptions\n  ) {\n    if (!instantsearchRequests || Array.isArray(instantsearchRequests) === false) {\n      console.log({ instantsearchRequests })\n      throw new Error(\n        'No instantsearch requests provided. Check that the data you are providing from API request is correct. Likely you are not passing the request body correctly, its still a JSON string or the API is not a POST request.'\n      )\n    }\n\n    const queryRules = this.config.search_settings.query_rules || []\n\n    const requestQueryRuleActions: QueryRuleActions[] = instantsearchRequests.map((request) => {\n      return getQueryRulesActionsFromRequest(queryRules, request, this.config.search_settings)\n    })\n\n    let esRequests: SearchRequest[] = instantsearchRequests.map((request, i) => ({\n      body: transformRequest(\n        request,\n        this.config.search_settings,\n        requestQueryRuleActions[i],\n        requestOptions\n      ),\n      request: request,\n      indexName: getIndexName(request.indexName, this.config.search_settings)\n    }))\n\n    if (requestOptions?.hooks?.beforeSearch) {\n      esRequests = await requestOptions.hooks.beforeSearch(esRequests)\n    }\n\n    let esResponses = await this.performSearch(esRequests)\n\n    if (requestOptions?.hooks?.afterSearch) {\n      esResponses = await requestOptions.hooks.afterSearch(esRequests, esResponses)\n    }\n\n    try {\n      const instantsearchResponses = esResponses.map((response, i) => {\n        // @ts-ignore\n        if (instantsearchRequests[i].params?.facetName) {\n          return transformFacetValuesResponse(response, instantsearchRequests[i])\n        }\n        return transformResponse(\n          response,\n          instantsearchRequests[i],\n          this.config.search_settings,\n          requestQueryRuleActions[i]\n        )\n      })\n\n      return {\n        results: instantsearchResponses\n      }\n    } catch (err) {\n      console.error(err)\n      throw new Error(\n        'Error transforming response. Check the afterSearch hook function is correct. Likely you are not returning the correct response object.'\n      )\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}