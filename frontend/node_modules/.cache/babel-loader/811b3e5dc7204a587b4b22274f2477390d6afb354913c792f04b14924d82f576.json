{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport { dequal } from \"./dequal.js\";\nimport { useInstantSearchContext } from \"./useInstantSearchContext.js\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect.js\";\nexport function useWidget(_ref) {\n  var widget = _ref.widget,\n    parentIndex = _ref.parentIndex,\n    props = _ref.props,\n    shouldSsr = _ref.shouldSsr;\n  var prevPropsRef = useRef(props);\n  useEffect(function () {\n    prevPropsRef.current = props;\n  }, [props]);\n  var prevWidgetRef = useRef(widget);\n  useEffect(function () {\n    prevWidgetRef.current = widget;\n  }, [widget]);\n  var cleanupTimerRef = useRef(null);\n  var shouldAddWidgetEarly = shouldSsr && !parentIndex.getWidgets().includes(widget);\n  var search = useInstantSearchContext();\n\n  // This effect is responsible for adding, removing, and updating the widget.\n  // We need to support scenarios where the widget is remounted quickly, like in\n  // Strict Mode, so that we don't lose its state, and therefore that we don't\n  // break routing.\n  useIsomorphicLayoutEffect(function () {\n    var previousWidget = prevWidgetRef.current;\n\n    // Scenario 1: the widget is added for the first time.\n    if (!cleanupTimerRef.current) {\n      if (!shouldAddWidgetEarly) {\n        parentIndex.addWidgets([widget]);\n      }\n    }\n    // Scenario 2: the widget is rerendered or updated.\n    else {\n      // We cancel the original effect cleanup because it may not be necessary if\n      // props haven't changed. (We manually call it if it is below.)\n      clearTimeout(cleanupTimerRef.current);\n\n      // Warning: if an unstable function prop is provided, `dequal` is not able\n      // to keep its reference and therefore will consider that props did change.\n      // This could unsollicitely remove/add the widget, therefore forget its state,\n      // and could be a source of confusion.\n      // If users face this issue, we should advise them to provide stable function\n      // references.\n      var arePropsEqual = dequal(props, prevPropsRef.current);\n\n      // If props did change, then we execute the cleanup function instantly\n      // and then add the widget back. This lets us add the widget without\n      // waiting for the scheduled cleanup function to finish (that we canceled\n      // above).\n      if (!arePropsEqual) {\n        parentIndex.removeWidgets([previousWidget]);\n        parentIndex.addWidgets([widget]);\n      }\n    }\n    return function () {\n      // We don't remove the widget right away, but rather schedule it so that\n      // we're able to cancel it in the next effect.\n      cleanupTimerRef.current = setTimeout(function () {\n        search._schedule(function () {\n          if (search._preventWidgetCleanup) return;\n          parentIndex.removeWidgets([previousWidget]);\n        });\n      });\n    };\n  }, [parentIndex, widget, shouldAddWidgetEarly, search, props]);\n  if (shouldAddWidgetEarly) {\n    parentIndex.addWidgets([widget]);\n  }\n}","map":{"version":3,"names":["useEffect","useRef","dequal","useInstantSearchContext","useIsomorphicLayoutEffect","useWidget","_ref","widget","parentIndex","props","shouldSsr","prevPropsRef","current","prevWidgetRef","cleanupTimerRef","shouldAddWidgetEarly","getWidgets","includes","search","previousWidget","addWidgets","clearTimeout","arePropsEqual","removeWidgets","setTimeout","_schedule","_preventWidgetCleanup"],"sources":["/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/react-instantsearch-hooks/dist/es/lib/useWidget.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { dequal } from \"./dequal.js\";\nimport { useInstantSearchContext } from \"./useInstantSearchContext.js\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect.js\";\nexport function useWidget(_ref) {\n  var widget = _ref.widget,\n    parentIndex = _ref.parentIndex,\n    props = _ref.props,\n    shouldSsr = _ref.shouldSsr;\n  var prevPropsRef = useRef(props);\n  useEffect(function () {\n    prevPropsRef.current = props;\n  }, [props]);\n  var prevWidgetRef = useRef(widget);\n  useEffect(function () {\n    prevWidgetRef.current = widget;\n  }, [widget]);\n  var cleanupTimerRef = useRef(null);\n  var shouldAddWidgetEarly = shouldSsr && !parentIndex.getWidgets().includes(widget);\n  var search = useInstantSearchContext();\n\n  // This effect is responsible for adding, removing, and updating the widget.\n  // We need to support scenarios where the widget is remounted quickly, like in\n  // Strict Mode, so that we don't lose its state, and therefore that we don't\n  // break routing.\n  useIsomorphicLayoutEffect(function () {\n    var previousWidget = prevWidgetRef.current;\n\n    // Scenario 1: the widget is added for the first time.\n    if (!cleanupTimerRef.current) {\n      if (!shouldAddWidgetEarly) {\n        parentIndex.addWidgets([widget]);\n      }\n    }\n    // Scenario 2: the widget is rerendered or updated.\n    else {\n      // We cancel the original effect cleanup because it may not be necessary if\n      // props haven't changed. (We manually call it if it is below.)\n      clearTimeout(cleanupTimerRef.current);\n\n      // Warning: if an unstable function prop is provided, `dequal` is not able\n      // to keep its reference and therefore will consider that props did change.\n      // This could unsollicitely remove/add the widget, therefore forget its state,\n      // and could be a source of confusion.\n      // If users face this issue, we should advise them to provide stable function\n      // references.\n      var arePropsEqual = dequal(props, prevPropsRef.current);\n\n      // If props did change, then we execute the cleanup function instantly\n      // and then add the widget back. This lets us add the widget without\n      // waiting for the scheduled cleanup function to finish (that we canceled\n      // above).\n      if (!arePropsEqual) {\n        parentIndex.removeWidgets([previousWidget]);\n        parentIndex.addWidgets([widget]);\n      }\n    }\n    return function () {\n      // We don't remove the widget right away, but rather schedule it so that\n      // we're able to cancel it in the next effect.\n      cleanupTimerRef.current = setTimeout(function () {\n        search._schedule(function () {\n          if (search._preventWidgetCleanup) return;\n          parentIndex.removeWidgets([previousWidget]);\n        });\n      });\n    };\n  }, [parentIndex, widget, shouldAddWidgetEarly, search, props]);\n  if (shouldAddWidgetEarly) {\n    parentIndex.addWidgets([widget]);\n  }\n}"],"mappings":"AAAA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACzC,SAASC,MAAM,QAAQ,aAAa;AACpC,SAASC,uBAAuB,QAAQ,8BAA8B;AACtE,SAASC,yBAAyB,QAAQ,gCAAgC;AAC1E,OAAO,SAASC,SAASA,CAACC,IAAI,EAAE;EAC9B,IAAIC,MAAM,GAAGD,IAAI,CAACC,MAAM;IACtBC,WAAW,GAAGF,IAAI,CAACE,WAAW;IAC9BC,KAAK,GAAGH,IAAI,CAACG,KAAK;IAClBC,SAAS,GAAGJ,IAAI,CAACI,SAAS;EAC5B,IAAIC,YAAY,GAAGV,MAAM,CAACQ,KAAK,CAAC;EAChCT,SAAS,CAAC,YAAY;IACpBW,YAAY,CAACC,OAAO,GAAGH,KAAK;EAC9B,CAAC,EAAE,CAACA,KAAK,CAAC,CAAC;EACX,IAAII,aAAa,GAAGZ,MAAM,CAACM,MAAM,CAAC;EAClCP,SAAS,CAAC,YAAY;IACpBa,aAAa,CAACD,OAAO,GAAGL,MAAM;EAChC,CAAC,EAAE,CAACA,MAAM,CAAC,CAAC;EACZ,IAAIO,eAAe,GAAGb,MAAM,CAAC,IAAI,CAAC;EAClC,IAAIc,oBAAoB,GAAGL,SAAS,IAAI,CAACF,WAAW,CAACQ,UAAU,CAAC,CAAC,CAACC,QAAQ,CAACV,MAAM,CAAC;EAClF,IAAIW,MAAM,GAAGf,uBAAuB,CAAC,CAAC;;EAEtC;EACA;EACA;EACA;EACAC,yBAAyB,CAAC,YAAY;IACpC,IAAIe,cAAc,GAAGN,aAAa,CAACD,OAAO;;IAE1C;IACA,IAAI,CAACE,eAAe,CAACF,OAAO,EAAE;MAC5B,IAAI,CAACG,oBAAoB,EAAE;QACzBP,WAAW,CAACY,UAAU,CAAC,CAACb,MAAM,CAAC,CAAC;MAClC;IACF;IACA;IAAA,KACK;MACH;MACA;MACAc,YAAY,CAACP,eAAe,CAACF,OAAO,CAAC;;MAErC;MACA;MACA;MACA;MACA;MACA;MACA,IAAIU,aAAa,GAAGpB,MAAM,CAACO,KAAK,EAAEE,YAAY,CAACC,OAAO,CAAC;;MAEvD;MACA;MACA;MACA;MACA,IAAI,CAACU,aAAa,EAAE;QAClBd,WAAW,CAACe,aAAa,CAAC,CAACJ,cAAc,CAAC,CAAC;QAC3CX,WAAW,CAACY,UAAU,CAAC,CAACb,MAAM,CAAC,CAAC;MAClC;IACF;IACA,OAAO,YAAY;MACjB;MACA;MACAO,eAAe,CAACF,OAAO,GAAGY,UAAU,CAAC,YAAY;QAC/CN,MAAM,CAACO,SAAS,CAAC,YAAY;UAC3B,IAAIP,MAAM,CAACQ,qBAAqB,EAAE;UAClClB,WAAW,CAACe,aAAa,CAAC,CAACJ,cAAc,CAAC,CAAC;QAC7C,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ,CAAC;EACH,CAAC,EAAE,CAACX,WAAW,EAAED,MAAM,EAAEQ,oBAAoB,EAAEG,MAAM,EAAET,KAAK,CAAC,CAAC;EAC9D,IAAIM,oBAAoB,EAAE;IACxBP,WAAW,CAACY,UAAU,CAAC,CAACb,MAAM,CAAC,CAAC;EAClC;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}