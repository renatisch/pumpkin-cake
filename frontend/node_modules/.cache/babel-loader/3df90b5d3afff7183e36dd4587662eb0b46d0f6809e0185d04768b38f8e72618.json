{"ast":null,"code":"// src/transformRequest.ts\nimport deepmerge from \"deepmerge\";\n\n// src/filterUtils.ts\nvar TermFilter = (field, value) => {\n  return {\n    term: {\n      [field]: value\n    }\n  };\n};\nvar MatchFilter = (field, value) => {\n  return {\n    match: {\n      [field]: value\n    }\n  };\n};\n\n// src/utils.ts\nvar getFacet = (facet_attributes, attributeName) => {\n  const f = facet_attributes.find(a => {\n    if (typeof a === \"string\") {\n      return a === attributeName;\n    }\n    return a.attribute === attributeName;\n  });\n  return f || null;\n};\nvar isNestedFacet = facet => {\n  return typeof facet !== \"string\" && !!facet.nestedPath;\n};\nvar getFacetFieldType = (facet_attributes, attribute) => {\n  var _a;\n  const attributeKey = typeof attribute === \"string\" ? attribute : attribute.attribute;\n  if (facet_attributes.includes(attributeKey)) {\n    return \"string\";\n  }\n  return ((_a = facet_attributes.find(a => (a == null ? void 0 : a.attribute) === attributeKey)) == null ? void 0 : _a.type) || \"string\";\n};\nvar createElasticsearchQueryFromRequest = requests => {\n  return requests.reduce((sum, request) => [...sum, JSON.stringify({\n    index: request.indexName\n  }), \"\\n\", JSON.stringify(request.body), \"\\n\"], []).join(\"\");\n};\n\n// src/filters.ts\nvar transformNumericFilters = (request, config) => {\n  const {\n    params = {}\n  } = request;\n  const {\n    numericFilters\n  } = params;\n  if (!Array.isArray(numericFilters)) {\n    return [];\n  }\n  return numericFilters.reduce((sum, filter) => {\n    let match,\n      field,\n      operator,\n      value,\n      maxValue = \"\";\n    let groups = filter.match(/([\\w\\.\\_\\-]+)\\s*(\\=|\\!\\=|\\>|\\>\\=|\\<|\\<\\=)\\s*(-?\\d+)/);\n    if (groups) {\n      [match, field, operator, value] = groups;\n    } else {\n      groups = filter.match(/([\\w\\.\\_\\-]+):\\s*(-?\\d+)\\s*([Tt][Oo])\\s*(-?\\d+)/);\n      if (!groups) {\n        throw new Error(`Numeric filter \"${filter}\" could not be parsed. It should either be in the format \"attributeName operator operand\" or \"attributeName: lowerBound TO upperBound\"`);\n      }\n      [match, field, value, operator, maxValue] = groups;\n    }\n    const facetFilterMap = getFacetFilterMap(config.facet_attributes || [], config.filter_attributes || []);\n    const facetFilterConfig = facetFilterMap[field];\n    const getFilter = (field2, operator2, value2) => {\n      if (operator2 === \"=\") {\n        return {\n          term: {\n            [field2]: value2\n          }\n        };\n      } else if (operator2 === \"!=\") {\n        return {\n          bool: {\n            must_not: {\n              term: {\n                [field2]: value2\n              }\n            }\n          }\n        };\n      } else if (operator2 === \">\") {\n        return {\n          range: {\n            [field2]: {\n              gt: value2\n            }\n          }\n        };\n      } else if (operator2 === \">=\") {\n        return {\n          range: {\n            [field2]: {\n              gte: value2\n            }\n          }\n        };\n      } else if (operator2 === \"<\") {\n        return {\n          range: {\n            [field2]: {\n              lt: value2\n            }\n          }\n        };\n      } else if (operator2 === \"<=\") {\n        return {\n          range: {\n            [field2]: {\n              lte: value2\n            }\n          }\n        };\n      } else if (operator2.toUpperCase() === \"TO\") {\n        return {\n          range: {\n            [field2]: {\n              gte: value2,\n              lte: maxValue\n            }\n          }\n        };\n      }\n    };\n    const esFilter = [];\n    if (facetFilterConfig.nestedPath) {\n      const nestedPathPresent = sum.find(filter2 => {\n        return filter2.nested.path === facetFilterConfig.nestedPath;\n      });\n      if (nestedPathPresent) {\n        nestedPathPresent.nested.query.bool.filter.push(getFilter(facetFilterConfig.nestedPath + \".\" + facetFilterConfig.field, operator, value));\n      } else {\n        esFilter.push({\n          nested: {\n            path: facetFilterConfig.nestedPath,\n            inner_hits: {},\n            query: {\n              bool: {\n                filter: [getFilter(facetFilterConfig.nestedPath + \".\" + facetFilterConfig.field, operator, value)]\n              }\n            }\n          }\n        });\n      }\n    } else {\n      esFilter.push(getFilter(facetFilterConfig.field, operator, value));\n    }\n    return [...sum, ...esFilter];\n  }, []);\n};\nvar getFacetFilterMap = (facets, filters) => {\n  return [...filters, ...facets].reduce((sum, filter) => {\n    let f = typeof filter === \"string\" ? {\n      attribute: filter,\n      field: filter,\n      type: \"string\"\n    } : filter;\n    return {\n      ...sum,\n      [f.attribute]: f\n    };\n  }, {});\n};\nvar transformFacetFilters = (request, config) => {\n  const {\n    params = {}\n  } = request;\n  const {\n    facetFilters\n  } = params;\n  if (!Array.isArray(facetFilters)) {\n    return [];\n  }\n  const facetFilterMap = getFacetFilterMap(config.facet_attributes || [], config.filter_attributes || []);\n  return facetFilters.reduce((sum, filter) => {\n    if (Array.isArray(filter)) {\n      return [...sum, {\n        bool: {\n          should: filter.reduce((sum2, filter2) => {\n            const [facet, value] = filter2.split(\":\");\n            const facetFilterConfig = facetFilterMap[facet];\n            if (!facetFilterConfig) throw new Error(`Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`);\n            const field = facetFilterConfig.field;\n            const filterClauseFn = facetFilterConfig.filterQuery || TermFilter;\n            if (isNestedFacet(facetFilterConfig)) {\n              const nestedFilter = sum2.find(filter3 => {\n                return filter3.nested && filter3.nested.path === facetFilterConfig.nestedPath;\n              });\n              if (nestedFilter) {\n                nestedFilter.nested.query.bool.should.push(filterClauseFn(`${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`, value));\n                return sum2;\n              } else {\n                return [...sum2, {\n                  nested: {\n                    inner_hits: {},\n                    path: facetFilterConfig.nestedPath,\n                    query: {\n                      bool: {\n                        should: [filterClauseFn(`${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`, value)]\n                      }\n                    }\n                  }\n                }];\n              }\n            }\n            return [...sum2, filterClauseFn(field, value)];\n          }, [])\n        }\n      }];\n    } else if (typeof filter === \"string\") {\n      const [facet, value] = filter.split(\":\");\n      const facetFilterConfig = facetFilterMap[facet];\n      if (!facetFilterConfig) throw new Error(`Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`);\n      const filterClauseFn = facetFilterConfig.filterQuery || TermFilter;\n      if (isNestedFacet(facetFilterConfig) && facetFilterConfig.nestedPath) {\n        const nestedFilter = sum.find(filter2 => {\n          return filter2.nested && filter2.nested.path === facetFilterConfig.nestedPath + \".\";\n        });\n        if (nestedFilter) {\n          nestedFilter.nested.query.bool.should.push(filterClauseFn(`${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`, value));\n          return sum;\n        } else {\n          return [...sum, {\n            nested: {\n              inner_hits: {},\n              path: facetFilterConfig.nestedPath,\n              query: {\n                bool: {\n                  should: [filterClauseFn(`${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`, value)]\n                }\n              }\n            }\n          }];\n        }\n      }\n      return [...sum, filterClauseFn(facetFilterConfig.field, value)];\n    }\n  }, []);\n};\nvar transformQueryString = (facets = [], filters = [], queryString) => {\n  const regex = /([\\w\\.\\-]+)\\:/gi;\n  const filterMap = getFacetFilterMap(facets, filters);\n  return queryString.replace(regex, (match, word) => {\n    if (!filterMap[word]) {\n      throw new Error(`Attribute \"${word}\" is not defined as an attribute in the facet or filter search settings`);\n    }\n    if (!!filterMap[word].nestedPath) {\n      throw new Error(`Attribute \"${word}\" is a nested field and cannot be used as a filter. Nested fields are supported in facetFilers or numericFilters.`);\n    }\n    return filterMap[word].field + \":\";\n  });\n};\nvar transformBaseFilters = (request, config) => {\n  const {\n    params = {}\n  } = request;\n  const {\n    filters\n  } = params;\n  if (!filters || filters === \"\") {\n    return [];\n  }\n  const queryString = transformQueryString(config.facet_attributes, config.filter_attributes, filters);\n  return [{\n    query_string: {\n      query: queryString\n    }\n  }];\n};\nvar transformGeoFilters = (request, config) => {\n  if (!config.geo_attribute) {\n    return [];\n  }\n  const {\n    params = {}\n  } = request;\n  const {\n    aroundLatLng,\n    aroundRadius,\n    insideBoundingBox\n  } = params;\n  if (insideBoundingBox) {\n    return [insideBoundingBoxFilter(insideBoundingBox, config.geo_attribute)];\n  }\n  if (aroundLatLng) {\n    const geoPoint = aroundLatLng.split(\",\");\n    return [{\n      geo_distance: {\n        distance: aroundRadius || \"1000m\",\n        [config.geo_attribute]: {\n          lat: geoPoint[0],\n          lon: geoPoint[1]\n        }\n      }\n    }];\n  }\n  return [];\n};\nfunction insideBoundingBoxFilter(insideBoundingBox, field) {\n  const geoBoundingboxFilter = (top, left, bottom, right) => {\n    return {\n      geo_bounding_box: {\n        [field]: {\n          top_right: {\n            lat: top,\n            lon: left\n          },\n          bottom_left: {\n            lat: bottom,\n            lon: right\n          }\n        }\n      }\n    };\n  };\n  if (typeof insideBoundingBox === \"string\") {\n    const [top, left, bottom, right] = insideBoundingBox.split(\",\");\n    return geoBoundingboxFilter(parseFloat(top), parseFloat(left), parseFloat(bottom), parseFloat(right));\n  } else if (Array.isArray(insideBoundingBox)) {\n    const geoBoundingboxes = insideBoundingBox.map(boundingBox => {\n      const [top, left, bottom, right] = boundingBox;\n      return geoBoundingboxFilter(parseFloat(top), parseFloat(left), parseFloat(bottom), parseFloat(right));\n    });\n    return {\n      bool: {\n        should: geoBoundingboxes\n      }\n    };\n  }\n}\n\n// src/sorting.ts\nfunction getSorting(request, config) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find(key => {\n      if (request.indexName.endsWith(key)) {\n        return true;\n      }\n    });\n    if (!selectedSorting && !config.sorting.default) return {};\n    const sortOption = selectedSorting ? config.sorting[selectedSorting] : config.sorting.default;\n    if (Array.isArray(sortOption)) {\n      return {\n        sort: sortOption.map(sorting => {\n          return {\n            [sorting.field]: sorting.order\n          };\n        })\n      };\n    } else {\n      return {\n        sort: {\n          [sortOption.field]: sortOption.order\n        }\n      };\n    }\n  }\n  return {};\n}\nfunction getIndexName(indexName, config) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find(key => {\n      if (indexName.endsWith(key)) {\n        return true;\n      }\n    });\n    if (selectedSorting) {\n      return indexName.replace(selectedSorting, \"\");\n    }\n  }\n  return indexName;\n}\n\n// src/transformRequest.ts\nvar createRegexQuery = queryString => {\n  let query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n  query = query.split(\"\").map(char => {\n    if (/[a-z]/.test(char)) {\n      return `[${char}${char.toUpperCase()}]`;\n    }\n    return char;\n  }).join(\"\");\n  query = `${query}.*`;\n  if (queryString.length > 2) {\n    query = `([a-zA-Z]+ )+?${query}`;\n  }\n  return query;\n};\nvar TermAggregation = (field, size, search) => {\n  const searchInclude = search && search.length > 0 ? {\n    include: createRegexQuery(search)\n  } : {};\n  return {\n    terms: {\n      field,\n      size,\n      ...searchInclude\n    }\n  };\n};\nvar getTermAggregation = (facet, size, search) => {\n  let aggEntries = {};\n  const AggregationFn = typeof facet !== \"string\" && facet.facetQuery ? facet.facetQuery : TermAggregation;\n  const getInnerAggs = (facetName, field) => {\n    if (typeof facet === \"string\" || facet.type === \"string\") {\n      aggEntries = {\n        [facetName]: AggregationFn(field, size, search)\n      };\n    } else if (facet.type === \"numeric\") {\n      aggEntries = {\n        [facetName + \"$_stats\"]: {\n          stats: {\n            field\n          }\n        },\n        [facetName + \"$_entries\"]: AggregationFn(field, size, search)\n      };\n    }\n    return aggEntries;\n  };\n  if (typeof facet === \"string\") {\n    return getInnerAggs(facet, facet);\n  } else if (isNestedFacet(facet)) {\n    return {\n      [`${facet.nestedPath}.`]: {\n        nested: {\n          path: facet.nestedPath\n        },\n        aggs: getInnerAggs(facet.attribute, `${facet.nestedPath}.${facet.field}`)\n      }\n    };\n  } else {\n    return getInnerAggs(facet.attribute, facet.field);\n  }\n};\nvar getAggs = (request, config, queryRuleActions) => {\n  const {\n    params = {},\n    type\n  } = request;\n  const {\n    facets,\n    maxValuesPerFacet,\n    facetName,\n    facetQuery\n  } = params;\n  const maxFacetSize = maxValuesPerFacet || 10;\n  const facetAttributes = config.facet_attributes || [];\n  if (facetName) {\n    const facet = getFacet(facetAttributes, facetName);\n    if (!facet) return null;\n    return getTermAggregation(facet, maxFacetSize, facetQuery);\n  } else if (Array.isArray(facets)) {\n    let facetAttibutes = config.facet_attributes || [];\n    if (queryRuleActions.facetAttributesOrder) {\n      facetAttibutes = queryRuleActions.facetAttributesOrder.map(attribute => {\n        return getFacet(config.facet_attributes || [], attribute);\n      }).filter(x => x !== null);\n    }\n    const facetAttributes2 = facets[0] === \"*\" ? facetAttibutes : facets.map(facetAttribute => {\n      return getFacet(config.facet_attributes || [], facetAttribute);\n    }).filter(x => x !== null);\n    return facetAttributes2.reduce((sum, facet) => {\n      return deepmerge(sum, getTermAggregation(facet, maxFacetSize, \"\"));\n    }, {}) || {};\n  } else if (typeof facets === \"string\") {\n    const field = getFacet(config.facet_attributes || [], facets);\n    if (!field) return {};\n    return getTermAggregation(field, maxFacetSize, \"\");\n  }\n};\nfunction queryRulesWrapper(organicQuery, queryRuleActions) {\n  if (queryRuleActions.touched) {\n    return {\n      function_score: {\n        query: {\n          pinned: {\n            ids: queryRuleActions.pinnedDocs,\n            organic: organicQuery\n          }\n        },\n        functions: queryRuleActions.boostFunctions\n      }\n    };\n  }\n  return organicQuery;\n}\nfunction RelevanceQueryMatch(query, search_attributes) {\n  const getFieldsMap = boostMultiplier => {\n    return search_attributes.map(attribute => {\n      return typeof attribute === \"string\" ? attribute : `${attribute.field}^${(attribute.weight || 1) * boostMultiplier}`;\n    });\n  };\n  return {\n    bool: {\n      should: [{\n        bool: {\n          should: [{\n            multi_match: {\n              query,\n              fields: getFieldsMap(1),\n              fuzziness: \"AUTO:4,8\"\n            }\n          }, {\n            multi_match: {\n              query,\n              fields: getFieldsMap(0.5),\n              type: \"bool_prefix\"\n            }\n          }]\n        }\n      }, {\n        multi_match: {\n          query,\n          type: \"phrase\",\n          fields: getFieldsMap(2)\n        }\n      }]\n    }\n  };\n}\nvar getQuery = (request, config, queryRuleActions, requestOptions) => {\n  var _a, _b, _c;\n  const query = queryRuleActions.query;\n  const searchAttributes = config.search_attributes;\n  const filters = [...transformFacetFilters(request, config), ...transformNumericFilters(request, config), ...transformBaseFilters(request, config), ...transformGeoFilters(request, config), ...(((_a = requestOptions == null ? void 0 : requestOptions.getBaseFilters) == null ? void 0 : _a.call(requestOptions)) || []), ...queryRuleActions.baseFilters];\n  let organicQuery = typeof query === \"string\" && query !== \"\" ? (requestOptions == null ? void 0 : requestOptions.getQuery) ? requestOptions.getQuery(query, searchAttributes, config) : RelevanceQueryMatch(query, searchAttributes) : {\n    match_all: {}\n  };\n  const hasKnn = typeof (requestOptions == null ? void 0 : requestOptions.getKnnQuery) === \"function\";\n  const hasNoQuery = ((_b = requestOptions == null ? void 0 : requestOptions.getQuery) == null ? void 0 : _b.call(requestOptions, query, searchAttributes, config)) === false;\n  if (hasNoQuery || hasKnn && query === \"\") {\n    organicQuery = {\n      match_all: {}\n    };\n  }\n  const queryDsl = {\n    bool: {\n      filter: filters,\n      must: queryRuleActions.touched ? queryRulesWrapper(organicQuery, queryRuleActions) : organicQuery\n    }\n  };\n  let knnQueryDsl = null;\n  if (hasKnn && query !== \"\") {\n    knnQueryDsl = {\n      filter: filters,\n      ...(((_c = requestOptions == null ? void 0 : requestOptions.getKnnQuery) == null ? void 0 : _c.call(requestOptions, query, searchAttributes, config)) || {})\n    };\n  }\n  if (query !== \"\" && hasNoQuery && hasKnn && knnQueryDsl) {\n    return {\n      knn: knnQueryDsl\n    };\n  }\n  const size = getHitsPerPage(request);\n  return {\n    query: queryDsl,\n    knn: knnQueryDsl ? knnQueryDsl : void 0,\n    rank: hasKnn && !hasNoQuery && size > 0 && query !== \"\" ? {\n      rrf: {\n        window_size: size\n      }\n    } : void 0\n  };\n};\nvar getHitsPerPage = request => {\n  const {\n    params = {}\n  } = request;\n  return params.hitsPerPage == null ? 20 : params.hitsPerPage;\n};\nvar getResultsSize = (request, config) => {\n  const {\n    params = {}\n  } = request;\n  const hitsPerPage = getHitsPerPage(request);\n  return {\n    size: hitsPerPage,\n    from: (params.page || 0) * hitsPerPage\n  };\n};\nvar getHitFields = (request, config) => {\n  const {\n    params = {}\n  } = request;\n  const {\n    attributesToRetrieve\n  } = params;\n  const sourceFields = /* @__PURE__ */new Set([...(config.result_attributes || []), ...(config.highlight_attributes || []), ...(config.geo_attribute ? [config.geo_attribute] : [])]);\n  const runtimeFields = Object.keys(config.runtime_mappings || {});\n  const fields = runtimeFields.reduce((sum, field) => {\n    var _a;\n    if ((_a = config.result_attributes) == null ? void 0 : _a.includes(field)) {\n      return [field, ...sum];\n    }\n    return sum;\n  }, []);\n  return {\n    _source: {\n      includes: Array.from(sourceFields)\n    },\n    ...(fields.length > 0 ? {\n      fields\n    } : {})\n  };\n};\nvar getSnippetFieldLength = attribute => {\n  const defaultMatch = {\n    attribute,\n    length: 100\n  };\n  if (!attribute.includes(\":\")) {\n    return defaultMatch;\n  }\n  const match = attribute.match(/(.+)\\:(\\d+)/);\n  if (!match) return defaultMatch;\n  return {\n    attribute: match[1],\n    length: parseInt(match[2])\n  };\n};\nvar getHighlightFields = (request, config) => {\n  var _a, _b;\n  const {\n    params = {}\n  } = request;\n  const {\n    attributesToHighlight\n  } = params;\n  const highlightFields = ((_a = config.highlight_attributes) == null ? void 0 : _a.reduce((sum, field) => ({\n    ...sum,\n    [field]: {\n      number_of_fragments: 0\n    }\n  }), {})) || {};\n  const snippetFields = ((_b = config.snippet_attributes) == null ? void 0 : _b.reduce((sum, attribute) => ({\n    ...sum,\n    [getSnippetFieldLength(attribute).attribute]: {\n      number_of_fragments: 5,\n      fragment_size: getSnippetFieldLength(attribute).length\n    }\n  }), {})) || {};\n  if (Object.keys(highlightFields).length === 0 && Object.keys(snippetFields).length === 0) {\n    return {};\n  }\n  return {\n    highlight: {\n      pre_tags: [\"<em>\"],\n      post_tags: [\"</em>\"],\n      fields: {\n        ...highlightFields,\n        ...snippetFields\n      }\n    }\n  };\n};\nvar getRuntimeMappings = (request, config) => {\n  if (!config.runtime_mappings) {\n    return {};\n  }\n  return {\n    runtime_mappings: config.runtime_mappings\n  };\n};\nfunction transformRequest(request, config, queryRuleActions, requestOptions) {\n  const body = {\n    aggs: getAggs(request, config, queryRuleActions),\n    ...getQuery(request, config, queryRuleActions, requestOptions),\n    ...getResultsSize(request, config),\n    ...getHitFields(request, config),\n    ...getHighlightFields(request, config),\n    ...getSorting(request, config),\n    ...getRuntimeMappings(request, config)\n  };\n  return body;\n}\n\n// src/highlightUtils.ts\nfunction highlightTerm(value, query) {\n  const regex = new RegExp(query, \"gi\");\n  return value.replace(regex, match => `<em>${match}</em>`);\n}\nfunction isAllowableHighlightField(fieldKey, highlightFields) {\n  return highlightFields.findIndex(highlightField => {\n    if (highlightField.indexOf(\"*\") < 0) {\n      return highlightField === fieldKey;\n    }\n    const safeHighlightField = highlightField.replace(/[.+?^$|\\{\\}\\(\\)\\[\\]\\\\]/g, \"\\\\$&\");\n    const regex = new RegExp(`^${safeHighlightField.replace(/\\*/g, \".*\")}$`);\n    return regex.test(fieldKey);\n  }) >= 0;\n}\nfunction getHighlightFields2(hit, preTag = \"<ais-highlight-0000000000>\", postTag = \"<ais-highlight-0000000000/>\", fields = []) {\n  const {\n    _source = {},\n    highlight = {}\n  } = hit;\n  const combinedKeys = {\n    ..._source,\n    ...highlight\n  };\n  const highlightFields = fields.map(field => getSnippetFieldLength(field).attribute);\n  const hitHighlights = Object.keys(combinedKeys).reduce((sum, fieldKey) => {\n    const fieldValue = _source[fieldKey];\n    const highlightedMatch = highlight[fieldKey] || null;\n    if (!isAllowableHighlightField(fieldKey, highlightFields)) {\n      return sum;\n    }\n    if (Array.isArray(fieldValue) && !highlightedMatch) {\n      return {\n        ...sum,\n        [fieldKey]: fieldValue.map(value => ({\n          matchLevel: \"none\",\n          matchedWords: [],\n          value: value.toString()\n        }))\n      };\n    } else if (Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) {\n      return {\n        ...sum,\n        [fieldKey]: highlightedMatch.map(highlightedMatch2 => {\n          const matchWords = Array.from(highlightedMatch2.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(match => match[1]);\n          return {\n            fullyHighlighted: false,\n            matchLevel: \"full\",\n            matchedWords: matchWords,\n            value: highlightedMatch2.toString().replace(/\\<em\\>/g, preTag).replace(/\\<\\/em\\>/g, postTag)\n          };\n        })\n      };\n    } else if (!Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch) || !fieldValue && Array.isArray(highlightedMatch) && highlightedMatch.length > 0) {\n      const singleMatch = highlightedMatch[0];\n      const matchWords = Array.from(singleMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(match => match[1]);\n      const x = {\n        fullyHighlighted: false,\n        matchLevel: \"full\",\n        matchedWords: matchWords,\n        value: singleMatch.toString().replace(/\\<em\\>/g, preTag).replace(/\\<\\/em\\>/g, postTag)\n      };\n      return {\n        ...sum,\n        [fieldKey]: x\n      };\n    }\n    return {\n      ...sum,\n      [fieldKey]: {\n        matchLevel: \"none\",\n        matchedWords: [],\n        value: fieldValue != void 0 ? fieldValue.toString() : \"\"\n      }\n    };\n  }, {});\n  return hitHighlights;\n}\n\n// src/transformResponse.ts\nvar getHits = (response, config, instantsearchRequest) => {\n  const {\n    hits\n  } = response;\n  const {\n    highlight_attributes = [],\n    snippet_attributes = []\n  } = config;\n  return hits.hits.map(hit => {\n    var _a, _b, _c, _d, _e, _f;\n    return {\n      objectID: hit._id,\n      _index: hit == null ? void 0 : hit._index,\n      ...(hit._source || {}),\n      ...(hit.fields || {}),\n      ...(hit.inner_hits ? {\n        inner_hits: hit.inner_hits\n      } : {}),\n      ...(highlight_attributes.length > 0 ? {\n        _highlightResult: getHighlightFields2(hit, (_a = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _a.highlightPreTag, (_b = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _b.highlightPostTag, highlight_attributes)\n      } : {}),\n      ...(snippet_attributes.length > 0 ? {\n        _snippetResult: getHighlightFields2(hit, (_c = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _c.highlightPreTag, (_d = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _d.highlightPostTag, config.snippet_attributes)\n      } : {}),\n      ...(config.geo_attribute && ((_e = hit._source) == null ? void 0 : _e[config.geo_attribute]) ? {\n        _geoloc: convertLatLng((_f = hit._source) == null ? void 0 : _f[config.geo_attribute])\n      } : {})\n    };\n  });\n};\nfunction convertLatLng(value) {\n  if (typeof value === \"string\") {\n    const [lat, lng] = value.split(\",\").map(v => parseFloat(v));\n    return {\n      lat,\n      lng\n    };\n  } else if (Array.isArray(value)) {\n    return {\n      lat: value[0],\n      lng: value[1]\n    };\n  } else if (typeof value === \"object\") {\n    if (\"lat\" in value && \"lon\" in value) {\n      return {\n        lat: parseFloat(value.lat),\n        lng: parseFloat(value.lon)\n      };\n    }\n  }\n  return null;\n}\nvar getFacets = (response, config) => {\n  if (!(response == null ? void 0 : response.aggregations)) {\n    return {};\n  }\n  const aggregations = Object.keys(response.aggregations).reduce((sum, key) => {\n    const value = (response.aggregations || {})[key];\n    if (key.endsWith(\".\")) {\n      const {\n        doc_count,\n        ...nestedAggregations\n      } = value;\n      return {\n        ...sum,\n        ...nestedAggregations\n      };\n    }\n    return {\n      ...sum,\n      [key]: value\n    };\n  }, {});\n  return Object.keys(aggregations).reduce((sum, f) => {\n    const facet = f.split(\"$\")[0];\n    const fieldType = getFacetFieldType(config.facet_attributes || [], facet);\n    if (fieldType === \"numeric\") {\n      const facetValues = aggregations[facet + \"$_stats\"];\n      const {\n        buckets: buckets2\n      } = aggregations[facet + \"$_entries\"];\n      return {\n        ...sum,\n        facets: {\n          ...sum.facets,\n          [facet]: buckets2.reduce((sum2, bucket) => ({\n            ...sum2,\n            [bucket.key]: bucket.doc_count\n          }), {})\n        },\n        facets_stats: {\n          ...sum.facets_stats,\n          [facet]: {\n            min: facetValues.min,\n            avg: facetValues.avg,\n            max: facetValues.max,\n            sum: facetValues.sum\n          }\n        }\n      };\n    }\n    const {\n      buckets\n    } = aggregations[facet];\n    return {\n      ...sum,\n      facets: {\n        ...sum.facets,\n        [facet]: buckets.reduce((sum2, bucket) => ({\n          ...sum2,\n          [bucket.key]: bucket.doc_count\n        }), {})\n      }\n    };\n  }, {\n    facets: {},\n    facets_stats: {}\n  });\n};\nvar getRenderingContent = (config, queryRuleActions) => {\n  var _a, _b;\n  const defaultOrder = (_a = config.facet_attributes) == null ? void 0 : _a.map(facet => typeof facet === \"string\" ? facet : facet.attribute);\n  return {\n    renderingContent: {\n      facetOrdering: {\n        facets: {\n          order: queryRuleActions.facetAttributesOrder || defaultOrder || []\n        },\n        values: (_b = config.facet_attributes) == null ? void 0 : _b.reduce((sum, facet) => {\n          const facetName = typeof facet === \"string\" ? facet : facet.attribute;\n          if (queryRuleActions.facetAttributesOrder && !queryRuleActions.facetAttributesOrder.includes(facetName)) {\n            return sum;\n          }\n          return {\n            ...sum,\n            [facetName]: {\n              sortRemainingBy: \"count\"\n            }\n          };\n        }, {})\n      }\n    }\n  };\n};\nvar getPageDetails = (response, request, queryRuleActions) => {\n  const {\n    params = {}\n  } = request;\n  const {\n    hitsPerPage = 20,\n    page = 0\n  } = params;\n  const {\n    total\n  } = response.hits;\n  const totalHits = typeof total === \"number\" ? total : total == null ? void 0 : total.value;\n  const nbPages = hitsPerPage <= 0 ? 0 : Math.ceil((typeof total === \"number\" ? total : (total == null ? void 0 : total.value) || 0) / hitsPerPage);\n  return {\n    hitsPerPage,\n    processingTimeMS: response.took,\n    nbHits: totalHits,\n    page,\n    nbPages,\n    query: queryRuleActions.query\n  };\n};\nfunction transformResponse(response, instantsearchRequest, config, queryRuleActions) {\n  try {\n    return {\n      appliedRules: queryRuleActions.ruleIds,\n      exhaustiveNbHits: true,\n      exhaustiveFacetsCount: true,\n      exhaustiveTypo: true,\n      exhaustive: {\n        facetsCount: true,\n        nbHits: true,\n        typo: true\n      },\n      ...getPageDetails(response, instantsearchRequest, queryRuleActions),\n      ...getRenderingContent(config, queryRuleActions),\n      ...getFacets(response, config),\n      hits: getHits(response, config, instantsearchRequest),\n      index: instantsearchRequest.indexName,\n      params: new URLSearchParams(instantsearchRequest.params).toString(),\n      ...(queryRuleActions.userData.length > 0 ? {\n        userData: queryRuleActions.userData\n      } : {})\n    };\n  } catch (e) {\n    throw new Error(`Error transforming Elasticsearch response for index`);\n  }\n}\nvar transformFacetValuesResponse = (response, instantsearchRequest) => {\n  var _a, _b, _c;\n  const aggregations = response.aggregations || {};\n  const facetName = (_a = instantsearchRequest == null ? void 0 : instantsearchRequest.params) == null ? void 0 : _a.facetName;\n  const preTag = ((_b = instantsearchRequest.params) == null ? void 0 : _b.highlightPreTag) || \"<ais-highlight-0000000000>\";\n  const postTag = ((_c = instantsearchRequest.params) == null ? void 0 : _c.highlightPostTag) || \"<ais-highlight-0000000000/>\";\n  let agg = aggregations[Object.keys(aggregations)[0]];\n  if (agg && agg[facetName]) {\n    agg = agg[facetName];\n  }\n  return {\n    facetHits: agg.buckets.map(entry => ({\n      value: entry.key,\n      highlighted: highlightTerm(entry.key, instantsearchRequest.params.facetQuery || \"\").replace(/<\\em>/g, preTag).replace(/<\\/\\em>/g, postTag),\n      count: entry.doc_count\n    })),\n    exhaustiveFacetsCount: true,\n    processingTimeMS: response.took\n  };\n};\n\n// src/Transporter.ts\nvar authString = auth => {\n  if (typeof btoa === \"undefined\") {\n    return Buffer.from(auth.username + \":\" + auth.password).toString(\"base64\");\n  } else {\n    return btoa(auth.username + \":\" + auth.password);\n  }\n};\nfunction getHostFromCloud(cloudId) {\n  let cloudUrls;\n  if (typeof atob === \"undefined\") {\n    cloudUrls = Buffer.from(cloudId.split(\":\")[1], \"base64\").toString();\n  } else {\n    cloudUrls = atob(cloudId.split(\":\")[1]).split(\"$\");\n  }\n  return `https://${cloudUrls[1]}.${cloudUrls[0]}`;\n}\nvar ESTransporter = class {\n  constructor(config, settings) {\n    this.config = config;\n    this.settings = settings;\n  }\n  createElasticsearchQueryFromRequest(requests) {\n    return createElasticsearchQueryFromRequest(requests);\n  }\n  async performNetworkRequest(requests) {\n    if (this.config.host === void 0 && this.config.cloud_id === void 0) {\n      throw new Error(\"No Elasticsearch host or cloud_id specified. Please provide a host or cloud id in your Searchkit configuration.\");\n    }\n    const host = this.config.cloud_id ? getHostFromCloud(this.config.cloud_id) : this.config.host;\n    return fetch(`${host}/_msearch`, {\n      headers: {\n        ...(this.config.apiKey ? {\n          authorization: `ApiKey ${this.config.apiKey}`\n        } : {}),\n        \"content-type\": \"application/json\",\n        ...(this.config.headers || {}),\n        ...(this.config.auth ? {\n          Authorization: \"Basic \" + authString(this.config.auth)\n        } : {})\n      },\n      body: this.createElasticsearchQueryFromRequest(requests),\n      method: \"POST\"\n    });\n  }\n  async msearch(requests) {\n    var _a, _b, _c, _d, _e, _f;\n    try {\n      const response = await this.performNetworkRequest(requests);\n      const responses = await response.json();\n      if (this.settings.debug) {\n        console.log(\"Elasticsearch response:\");\n        console.log(JSON.stringify(responses));\n      }\n      if (responses.status >= 500) {\n        console.error(JSON.stringify(responses));\n        throw new Error(\"Elasticsearch Internal Error: Check your elasticsearch instance to make sure it can recieve requests.\");\n      } else if (responses.status === 401) {\n        console.error(JSON.stringify(responses));\n        throw new Error(\"Cannot connect to Elasticsearch. Check your connection host and auth details (username/password or API Key required). You can also provide a custom Elasticsearch transporter to the API Client. See https://www.searchkit.co/docs/guides/setup-elasticsearch#connecting-with-usernamepassword for more details.\");\n      } else if (((_b = (_a = responses.responses) == null ? void 0 : _a[0]) == null ? void 0 : _b.status) === 403) {\n        console.error(JSON.stringify(responses));\n        throw new Error(\"Auth Error: You do not have permission to access this index. Check you are calling the right index (specified in frontend) and your API Key permissions has access to the index.\");\n      } else if (responses.status === 404 || ((_d = (_c = responses.responses) == null ? void 0 : _c[0]) == null ? void 0 : _d.status) === 404) {\n        console.error(JSON.stringify(responses));\n        throw new Error(\"Elasticsearch index not found. Check your index name and make sure it exists.\");\n      } else if (responses.status === 400 || ((_f = (_e = responses.responses) == null ? void 0 : _e[0]) == null ? void 0 : _f.status) === 400) {\n        console.error(JSON.stringify(responses));\n        throw new Error(`Elasticsearch Bad Request. \n          \n          1. Check your query and make sure it is valid. \n          2. Check the field mapping. See documentation to make sure you are using text types for searching and keyword fields for faceting\n          3. Turn on debug mode to see the Elasticsearch query and the error response.\n          `);\n      }\n      return responses.responses;\n    } catch (error) {\n      throw error;\n    }\n  }\n};\n\n// src/queryRules.ts\nvar getFacetFilters = facetFilters => {\n  if (!facetFilters) {\n    return [];\n  }\n  if (typeof facetFilters === \"string\") {\n    const [attribute, value] = facetFilters.split(\":\");\n    return [{\n      attribute,\n      value\n    }];\n  } else {\n    return facetFilters.reduce((sum, filter) => {\n      if (typeof filter === \"string\") {\n        const [attribute, value] = filter.split(\":\");\n        return [...sum, {\n          attribute,\n          value\n        }];\n      }\n      return [...sum, ...getFacetFilters(filter)];\n    }, []);\n  }\n};\nvar getQueryRulesActionsFromRequest = (queryRules, request, config) => {\n  var _a, _b, _c;\n  const queryContext = {\n    query: ((_a = request.params) == null ? void 0 : _a.query) || \"\",\n    context: ((_b = request.params) == null ? void 0 : _b.ruleContexts) || [],\n    filters: getFacetFilters((_c = request.params) == null ? void 0 : _c.facetFilters)\n  };\n  const satisfiedRules = getSatisfiedRules(queryContext, queryRules || []);\n  const actions = satisfiedRules.reduce((sum, rule) => {\n    rule.actions.map(action => {\n      sum.touched = true;\n      if (action.action === \"PinnedResult\") {\n        sum.pinnedDocs.push(...action.documentIds);\n      } else if (action.action === \"QueryRewrite\") {\n        sum.query = action.query;\n      } else if (action.action === \"QueryBoost\") {\n        sum.boostFunctions.push({\n          filter: {\n            query_string: {\n              query: transformQueryString(config.facet_attributes, config.filter_attributes, action.query)\n            }\n          },\n          weight: action.weight\n        });\n      } else if (action.action === \"RenderUserData\") {\n        sum.userData.push(JSON.parse(action.userData));\n      } else if (action.action === \"RenderFacetsOrder\") {\n        sum.facetAttributesOrder = action.facetAttributesOrder;\n      } else if (action.action === \"QueryFilter\") {\n        sum.baseFilters.push({\n          query_string: {\n            query: transformQueryString(config.facet_attributes, config.filter_attributes, action.query)\n          }\n        });\n      }\n    });\n    return sum;\n  }, {\n    ruleIds: satisfiedRules.map(rule => rule.id),\n    pinnedDocs: [],\n    boostFunctions: [],\n    query: queryContext.query,\n    userData: [],\n    facetAttributesOrder: void 0,\n    touched: false,\n    baseFilters: []\n  });\n  return actions;\n};\nvar getSatisfiedRules = (queryContext, rules) => rules.filter(ruleOrs => ruleOrs.conditions.find(rule => rule.filter(condition => {\n  if (condition.context === \"query\" && condition.match_type === \"exact\") {\n    return condition.value === queryContext.query;\n  }\n  if (condition.context === \"query\" && condition.match_type === \"contains\") {\n    return queryContext.query.includes(condition.value);\n  }\n  if (condition.context === \"query\" && condition.match_type === \"prefix\") {\n    return queryContext.query.startsWith(condition.value);\n  }\n  if (condition.context === \"context\") {\n    return condition.value.some(value => queryContext.context.includes(value));\n  }\n  if (condition.context === \"filterPresent\") {\n    return condition.values.every(value => queryContext.filters.find(filter => filter.attribute === value.attribute && filter.value === value.value) !== void 0);\n  }\n  return false;\n}).length === rule.length) !== void 0);\n\n// src/index.ts\nvar Searchkit = class {\n  constructor(config, settings = {\n    debug: false\n  }) {\n    this.config = config;\n    this.settings = settings;\n    this.transporter = \"msearch\" in config.connection ? config.connection : new ESTransporter(config.connection, settings);\n  }\n  async performSearch(requests) {\n    try {\n      if (this.settings.debug) {\n        console.log(\"Performing search with requests:\");\n        console.log(\"POST /_msearch\");\n        console.log(createElasticsearchQueryFromRequest(requests));\n      }\n      const responses = await this.transporter.msearch(requests);\n      return responses;\n    } catch (err) {\n      console.error(err);\n      return [];\n    }\n  }\n  async handleInstantSearchRequests(instantsearchRequests, requestOptions) {\n    var _a, _b;\n    if (!instantsearchRequests || Array.isArray(instantsearchRequests) === false) {\n      console.log({\n        instantsearchRequests\n      });\n      throw new Error(\"No instantsearch requests provided. Check that the data you are providing from API request is correct. Likely you are not passing the request body correctly, its still a JSON string or the API is not a POST request.\");\n    }\n    const queryRules = this.config.search_settings.query_rules || [];\n    const requestQueryRuleActions = instantsearchRequests.map(request => {\n      return getQueryRulesActionsFromRequest(queryRules, request, this.config.search_settings);\n    });\n    let esRequests = instantsearchRequests.map((request, i) => ({\n      body: transformRequest(request, this.config.search_settings, requestQueryRuleActions[i], requestOptions),\n      request,\n      indexName: getIndexName(request.indexName, this.config.search_settings)\n    }));\n    if ((_a = requestOptions == null ? void 0 : requestOptions.hooks) == null ? void 0 : _a.beforeSearch) {\n      esRequests = await requestOptions.hooks.beforeSearch(esRequests);\n    }\n    let esResponses = await this.performSearch(esRequests);\n    if ((_b = requestOptions == null ? void 0 : requestOptions.hooks) == null ? void 0 : _b.afterSearch) {\n      esResponses = await requestOptions.hooks.afterSearch(esRequests, esResponses);\n    }\n    try {\n      const instantsearchResponses = esResponses.map((response, i) => {\n        var _a2;\n        if ((_a2 = instantsearchRequests[i].params) == null ? void 0 : _a2.facetName) {\n          return transformFacetValuesResponse(response, instantsearchRequests[i]);\n        }\n        return transformResponse(response, instantsearchRequests[i], this.config.search_settings, requestQueryRuleActions[i]);\n      });\n      return {\n        results: instantsearchResponses\n      };\n    } catch (err) {\n      console.error(err);\n      throw new Error(\"Error transforming response. Check the afterSearch hook function is correct. Likely you are not returning the correct response object.\");\n    }\n  }\n};\nexport { ESTransporter, MatchFilter, TermFilter, Searchkit as default };","map":{"version":3,"names":["deepmerge","TermFilter","field","value","term","MatchFilter","match","getFacet","facet_attributes","attributeName","f","find","a","attribute","isNestedFacet","facet","nestedPath","getFacetFieldType","_a","attributeKey","includes","type","createElasticsearchQueryFromRequest","requests","reduce","sum","request","JSON","stringify","index","indexName","body","join","transformNumericFilters","config","params","numericFilters","Array","isArray","filter","operator","maxValue","groups","Error","facetFilterMap","getFacetFilterMap","filter_attributes","facetFilterConfig","getFilter","field2","operator2","value2","bool","must_not","range","gt","gte","lt","lte","toUpperCase","esFilter","nestedPathPresent","filter2","nested","path","query","push","inner_hits","facets","filters","transformFacetFilters","facetFilters","should","sum2","split","filterClauseFn","filterQuery","nestedFilter","filter3","transformQueryString","queryString","regex","filterMap","replace","word","transformBaseFilters","query_string","transformGeoFilters","geo_attribute","aroundLatLng","aroundRadius","insideBoundingBox","insideBoundingBoxFilter","geoPoint","geo_distance","distance","lat","lon","geoBoundingboxFilter","top","left","bottom","right","geo_bounding_box","top_right","bottom_left","parseFloat","geoBoundingboxes","map","boundingBox","getSorting","sorting","Object","keys","length","selectedSorting","key","endsWith","default","sortOption","sort","order","getIndexName","createRegexQuery","char","test","TermAggregation","size","search","searchInclude","include","terms","getTermAggregation","aggEntries","AggregationFn","facetQuery","getInnerAggs","facetName","stats","aggs","getAggs","queryRuleActions","maxValuesPerFacet","maxFacetSize","facetAttributes","facetAttibutes","facetAttributesOrder","x","facetAttributes2","facetAttribute","queryRulesWrapper","organicQuery","touched","function_score","pinned","ids","pinnedDocs","organic","functions","boostFunctions","RelevanceQueryMatch","search_attributes","getFieldsMap","boostMultiplier","weight","multi_match","fields","fuzziness","getQuery","requestOptions","_b","_c","searchAttributes","getBaseFilters","call","baseFilters","match_all","hasKnn","getKnnQuery","hasNoQuery","queryDsl","must","knnQueryDsl","knn","getHitsPerPage","rank","rrf","window_size","hitsPerPage","getResultsSize","from","page","getHitFields","attributesToRetrieve","sourceFields","Set","result_attributes","highlight_attributes","runtimeFields","runtime_mappings","_source","getSnippetFieldLength","defaultMatch","parseInt","getHighlightFields","attributesToHighlight","highlightFields","number_of_fragments","snippetFields","snippet_attributes","fragment_size","highlight","pre_tags","post_tags","getRuntimeMappings","transformRequest","highlightTerm","RegExp","isAllowableHighlightField","fieldKey","findIndex","highlightField","indexOf","safeHighlightField","getHighlightFields2","hit","preTag","postTag","combinedKeys","hitHighlights","fieldValue","highlightedMatch","matchLevel","matchedWords","toString","highlightedMatch2","matchWords","matchAll","fullyHighlighted","singleMatch","getHits","response","instantsearchRequest","hits","_d","_e","_f","objectID","_id","_index","_highlightResult","highlightPreTag","highlightPostTag","_snippetResult","_geoloc","convertLatLng","lng","v","getFacets","aggregations","doc_count","nestedAggregations","fieldType","facetValues","buckets","buckets2","bucket","facets_stats","min","avg","max","getRenderingContent","defaultOrder","renderingContent","facetOrdering","values","sortRemainingBy","getPageDetails","total","totalHits","nbPages","Math","ceil","processingTimeMS","took","nbHits","transformResponse","appliedRules","ruleIds","exhaustiveNbHits","exhaustiveFacetsCount","exhaustiveTypo","exhaustive","facetsCount","typo","URLSearchParams","userData","e","transformFacetValuesResponse","agg","facetHits","entry","highlighted","count","authString","auth","btoa","Buffer","username","password","getHostFromCloud","cloudId","cloudUrls","atob","ESTransporter","constructor","settings","performNetworkRequest","host","cloud_id","fetch","headers","apiKey","authorization","Authorization","method","msearch","responses","json","debug","console","log","status","error","getFacetFilters","getQueryRulesActionsFromRequest","queryRules","queryContext","context","ruleContexts","satisfiedRules","getSatisfiedRules","actions","rule","action","documentIds","parse","id","rules","ruleOrs","conditions","condition","match_type","startsWith","some","every","Searchkit","transporter","connection","performSearch","err","handleInstantSearchRequests","instantsearchRequests","search_settings","query_rules","requestQueryRuleActions","esRequests","i","hooks","beforeSearch","esResponses","afterSearch","instantsearchResponses","_a2","results"],"sources":["/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/transformRequest.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/filterUtils.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/utils.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/filters.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/sorting.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/highlightUtils.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/transformResponse.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/Transporter.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/queryRules.ts","/Users/renat.ishmukhamedov/Documents/dev_projects/extractor/frontend/node_modules/searchkit/src/index.ts"],"sourcesContent":["import {\n  QueryDslQueryContainer,\n  RankContainer,\n  RrfRank\n} from '@elastic/elasticsearch/lib/api/types'\nimport deepmerge from 'deepmerge'\nimport {\n  transformBaseFilters,\n  transformFacetFilters,\n  transformGeoFilters,\n  transformNumericFilters\n} from './filters'\nimport { QueryRuleActions } from './queryRules'\nimport { getSorting } from './sorting'\nimport {\n  FacetAttribute,\n  KnnSearchQuery,\n  RequestOptions,\n  SearchAttribute,\n  SearchSettingsConfig\n} from './types'\nimport { AlgoliaMultipleQueriesQuery, ElasticsearchSearchRequest } from './types'\nimport { getFacet, isNestedFacet } from './utils'\n\nexport const createRegexQuery = (queryString: string) => {\n  let query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n  query = query\n    .split('')\n    .map((char) => {\n      if (/[a-z]/.test(char)) {\n        return `[${char}${char.toUpperCase()}]`\n      }\n      return char\n    })\n    .join('')\n  query = `${query}.*`\n  if (queryString.length > 2) {\n    query = `([a-zA-Z]+ )+?${query}`\n  }\n  return query\n}\n\nconst TermAggregation = (field: string, size: number, search: string) => {\n  const searchInclude = search && search.length > 0 ? { include: createRegexQuery(search) } : {}\n  return {\n    terms: {\n      field,\n      size,\n      ...searchInclude\n    }\n  }\n}\n\nconst getTermAggregation = (facet: FacetAttribute, size: number, search: string) => {\n  let aggEntries = {}\n  const AggregationFn =\n    typeof facet !== 'string' && facet.facetQuery ? facet.facetQuery : TermAggregation\n\n  const getInnerAggs = (facetName: string, field: string): any => {\n    if (typeof facet === 'string' || facet.type === 'string') {\n      aggEntries = {\n        [facetName]: AggregationFn(field, size, search)\n      }\n    } else if (facet.type === 'numeric') {\n      aggEntries = {\n        [facetName + '$_stats']: {\n          stats: {\n            field: field\n          }\n        },\n        [facetName + '$_entries']: AggregationFn(field, size, search)\n      }\n    }\n    return aggEntries\n  }\n\n  if (typeof facet === 'string') {\n    return getInnerAggs(facet, facet)\n  } else if (isNestedFacet(facet)) {\n    return {\n      [`${facet.nestedPath}.`]: {\n        nested: {\n          path: facet.nestedPath\n        },\n        aggs: getInnerAggs(facet.attribute, `${facet.nestedPath}.${facet.field}`)\n      }\n    }\n  } else {\n    return getInnerAggs(facet.attribute, facet.field)\n  }\n}\n\nexport const getAggs = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions\n) => {\n  const { params = {}, type } = request\n  // @ts-ignore\n  const { facets, maxValuesPerFacet, facetName, facetQuery } = params\n  const maxFacetSize = maxValuesPerFacet || 10\n  const facetAttributes = config.facet_attributes || []\n\n  if (facetName) {\n    const facet = getFacet(facetAttributes, facetName)\n    if (!facet) return null\n    return getTermAggregation(facet, maxFacetSize, facetQuery)\n  } else if (Array.isArray(facets)) {\n    let facetAttibutes = config.facet_attributes || []\n\n    if (queryRuleActions.facetAttributesOrder) {\n      facetAttibutes = queryRuleActions.facetAttributesOrder\n        .map((attribute) => {\n          return getFacet(config.facet_attributes || [], attribute)\n        })\n        .filter((x): x is FacetAttribute => x !== null)\n    }\n\n    const facetAttributes: FacetAttribute[] =\n      facets[0] === '*'\n        ? facetAttibutes\n        : facets\n            .map((facetAttribute) => {\n              return getFacet(config.facet_attributes || [], facetAttribute)\n            })\n            .filter((x): x is FacetAttribute => x !== null)\n\n    return (\n      facetAttributes.reduce((sum, facet) => {\n        return deepmerge(sum, getTermAggregation(facet, maxFacetSize, ''))\n      }, {}) || {}\n    )\n  } else if (typeof facets === 'string') {\n    const field = getFacet(config.facet_attributes || [], facets)\n    if (!field) return {}\n    return getTermAggregation(field, maxFacetSize, '')\n  }\n}\n\nfunction queryRulesWrapper(organicQuery: any, queryRuleActions: QueryRuleActions) {\n  if (queryRuleActions.touched) {\n    return {\n      function_score: {\n        query: {\n          pinned: {\n            ids: queryRuleActions.pinnedDocs,\n            organic: organicQuery\n          }\n        },\n        functions: queryRuleActions.boostFunctions\n      }\n    }\n  }\n  return organicQuery\n}\n\nexport function RelevanceQueryMatch(query: string, search_attributes: SearchAttribute[]) {\n  const getFieldsMap = (boostMultiplier: number) => {\n    return search_attributes.map((attribute) => {\n      return typeof attribute === 'string'\n        ? attribute\n        : `${attribute.field}^${(attribute.weight || 1) * boostMultiplier}`\n    })\n  }\n\n  return {\n    bool: {\n      should: [\n        {\n          bool: {\n            should: [\n              {\n                multi_match: {\n                  query: query,\n                  fields: getFieldsMap(1),\n                  fuzziness: 'AUTO:4,8'\n                }\n              },\n              {\n                multi_match: {\n                  query: query,\n                  fields: getFieldsMap(0.5),\n                  type: 'bool_prefix'\n                }\n              }\n            ]\n          }\n        },\n        {\n          multi_match: {\n            query: query,\n            type: 'phrase',\n            fields: getFieldsMap(2)\n          }\n        }\n      ]\n    }\n  }\n}\n\nconst getQuery = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions,\n  requestOptions?: RequestOptions\n): { query?: QueryDslQueryContainer; knn?: KnnSearchQuery; rank?: RankContainer } => {\n  const query = queryRuleActions.query\n\n  const searchAttributes = config.search_attributes\n\n  const filters = [\n    ...transformFacetFilters(request, config),\n    ...transformNumericFilters(request, config),\n    ...transformBaseFilters(request, config),\n    ...transformGeoFilters(request, config),\n    ...(requestOptions?.getBaseFilters?.() || []),\n    ...queryRuleActions.baseFilters\n  ]\n\n  let organicQuery =\n    typeof query === 'string' && query !== ''\n      ? requestOptions?.getQuery\n        ? requestOptions.getQuery(query, searchAttributes, config)\n        : RelevanceQueryMatch(query, searchAttributes)\n      : {\n          match_all: {}\n        }\n\n  const hasKnn = typeof requestOptions?.getKnnQuery === 'function'\n  const hasNoQuery = requestOptions?.getQuery?.(query, searchAttributes, config) === false\n\n  if (hasNoQuery || (hasKnn && query === '')) {\n    organicQuery = {\n      match_all: {}\n    }\n  }\n\n  const queryDsl = {\n    bool: {\n      filter: filters,\n      must: queryRuleActions.touched\n        ? queryRulesWrapper(organicQuery, queryRuleActions)\n        : organicQuery\n    }\n  }\n\n  let knnQueryDsl: KnnSearchQuery | null = null\n\n  if (hasKnn && query !== '') {\n    knnQueryDsl = {\n      filter: filters,\n      ...(requestOptions?.getKnnQuery?.(query, searchAttributes, config) || {})\n    } as KnnSearchQuery\n  }\n\n  if (query !== '' && hasNoQuery && hasKnn && knnQueryDsl) {\n    return {\n      knn: knnQueryDsl\n    }\n  }\n\n  const size = getHitsPerPage(request)\n\n  return {\n    query: queryDsl,\n    knn: knnQueryDsl ? knnQueryDsl : undefined,\n    // in hybrid mode (knn + keyword query), is displaying results and query is not empty\n    rank:\n      hasKnn && !hasNoQuery && size > 0 && query !== '' ? { rrf: { window_size: size } } : undefined\n  }\n}\n\nconst getHitsPerPage = (request: AlgoliaMultipleQueriesQuery) => {\n  const { params = {} } = request\n  return params.hitsPerPage == null ? 20 : params.hitsPerPage\n}\n\nconst getResultsSize = (request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) => {\n  const { params = {} } = request\n  const hitsPerPage = getHitsPerPage(request)\n\n  return {\n    size: hitsPerPage,\n    from: (params.page || 0) * hitsPerPage\n  }\n}\n\nexport const getHitFields = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { attributesToRetrieve } = params\n  // ignoring attributesToRetrieve for now\n\n  const sourceFields = new Set([\n    ...(config.result_attributes || []),\n    ...(config.highlight_attributes || []),\n    ...(config.geo_attribute ? [config.geo_attribute] : [])\n  ])\n\n  const runtimeFields = Object.keys(config.runtime_mappings || {})\n  const fields = runtimeFields.reduce<string[]>((sum, field) => {\n    if (config.result_attributes?.includes(field)) {\n      return [field, ...sum]\n    }\n    return sum\n  }, [])\n\n  return {\n    _source: {\n      includes: Array.from(sourceFields)\n    },\n    ...(fields.length > 0 ? { fields } : {})\n  }\n}\n\nexport const getSnippetFieldLength = (attribute: string) => {\n  const defaultMatch = {\n    attribute,\n    length: 100\n  }\n  if (!attribute.includes(':')) {\n    return defaultMatch\n  }\n  const match = attribute.match(/(.+)\\:(\\d+)/)\n  if (!match) return defaultMatch\n  return {\n    attribute: match[1],\n    length: parseInt(match[2])\n  }\n}\n\nexport const getHighlightFields = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { attributesToHighlight } = params\n  // ignoring attributesToHighlight for now\n\n  const highlightFields =\n    config.highlight_attributes?.reduce(\n      (sum, field) => ({\n        ...sum,\n        [field]: {\n          number_of_fragments: 0\n        }\n      }),\n      {}\n    ) || {}\n\n  const snippetFields =\n    config.snippet_attributes?.reduce(\n      (sum, attribute) => ({\n        ...sum,\n        [getSnippetFieldLength(attribute).attribute]: {\n          number_of_fragments: 5,\n          fragment_size: getSnippetFieldLength(attribute).length\n        }\n      }),\n      {}\n    ) || {}\n\n  if (Object.keys(highlightFields).length === 0 && Object.keys(snippetFields).length === 0) {\n    return {}\n  }\n\n  return {\n    highlight: {\n      pre_tags: ['<em>'],\n      post_tags: ['</em>'],\n      fields: {\n        ...highlightFields,\n        ...snippetFields\n      }\n    }\n  }\n}\n\nconst getRuntimeMappings = (request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) => {\n  if (!config.runtime_mappings) {\n    return {}\n  }\n\n  return {\n    runtime_mappings: config.runtime_mappings\n  }\n}\n\nexport function transformRequest(\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions,\n  requestOptions?: RequestOptions\n): ElasticsearchSearchRequest {\n  const body: ElasticsearchSearchRequest = {\n    aggs: getAggs(request, config, queryRuleActions),\n    ...getQuery(request, config, queryRuleActions, requestOptions),\n    ...getResultsSize(request, config),\n    ...getHitFields(request, config),\n    ...getHighlightFields(request, config),\n    ...getSorting(request, config),\n    ...getRuntimeMappings(request, config)\n  }\n\n  return body\n}\n","export const TermFilter = (field: string, value: string) => {\n  return { term: { [field]: value } }\n}\n\nexport const MatchFilter = (field: string, value: string) => {\n  return { match: { [field]: value } }\n}\n","import { FacetAttribute, FacetFieldConfig, SearchRequest } from './types'\n\nexport const createRegexQuery = (queryString: string) => {\n  let query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n  query = query\n    .split('')\n    .map((char) => {\n      if (/[a-z]/.test(char)) {\n        return `[${char}${char.toUpperCase()}]`\n      }\n      return char\n    })\n    .join('')\n  query = `${query}.*`\n  if (queryString.length > 2) {\n    query = `([a-zA-Z]+ )+?${query}`\n  }\n  return query\n}\n\nexport const getFacet = (\n  facet_attributes: FacetAttribute[],\n  attributeName: string\n): FacetAttribute | null => {\n  const f = facet_attributes.find((a) => {\n    if (typeof a === 'string') {\n      return a === attributeName\n    }\n    return a.attribute === attributeName\n  })\n  return f || null\n}\n\nexport const isNestedFacet = (facet: FacetAttribute): boolean => {\n  return typeof facet !== 'string' && !!facet.nestedPath\n}\n\nexport const getFacetField = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): string => {\n  const attributeKey = typeof attribute === 'string' ? attribute : attribute.attribute\n\n  if (facet_attributes.includes(attributeKey)) {\n    return attributeKey\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a.attribute === attributeKey)?.field || attributeKey\n  )\n}\n\nexport const getFacetByAttribute = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): string => {\n  const attributeKey = getFacetAttribute(attribute)\n\n  if (facet_attributes.includes(attributeKey)) {\n    return attributeKey\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a.attribute === attributeKey)?.attribute || attributeKey\n  )\n}\n\nexport const getFacetAttribute = (facetAttribute: FacetAttribute): string => {\n  return typeof facetAttribute === 'string' ? facetAttribute : facetAttribute.attribute\n}\n\nexport const getFacetFieldType = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): FacetFieldConfig['type'] => {\n  const attributeKey = typeof attribute === 'string' ? attribute : attribute.attribute\n\n  if (facet_attributes.includes(attributeKey)) {\n    return 'string'\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a?.attribute === attributeKey)?.type || 'string'\n  )\n}\n\nexport const createElasticsearchQueryFromRequest = (requests: SearchRequest[]) => {\n  return requests\n    .reduce<string[]>(\n      (sum, request) => [\n        ...sum,\n        JSON.stringify({ index: request.indexName }),\n        '\\n',\n        JSON.stringify(request.body),\n        '\\n'\n      ],\n      []\n    )\n    .join('')\n}\n","import { MatchFilter, TermFilter } from './filterUtils'\nimport type {\n  AlgoliaMultipleQueriesQuery,\n  FacetAttribute,\n  SearchSettingsConfig,\n  ElasticsearchQuery,\n  FilterAttribute,\n  FacetFieldConfig\n} from './types'\nimport { getFacet, getFacetAttribute, isNestedFacet } from './utils'\n\nexport const transformNumericFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n): ElasticsearchQuery[] => {\n  const { params = {} } = request\n  const { numericFilters } = params\n\n  if (!Array.isArray(numericFilters)) {\n    return []\n  }\n\n  return numericFilters.reduce((sum, filter: string) => {\n    let match, field, operator, value, maxValue = ''\n    let groups = filter.match(\n      /([\\w\\.\\_\\-]+)\\s*(\\=|\\!\\=|\\>|\\>\\=|\\<|\\<\\=)\\s*(-?\\d+)/\n    )\n\n    if (groups) {\n      [match, field, operator, value] = groups\n    }\n    else {\n      // Alternative syntax: 'attribute:lower_value TO higher_value'\n      groups = filter.match(\n        /([\\w\\.\\_\\-]+):\\s*(-?\\d+)\\s*([Tt][Oo])\\s*(-?\\d+)/\n      )\n\n      if (!groups) {\n        throw new Error(\n          `Numeric filter \"${filter}\" could not be parsed. It should either be in the format \"attributeName operator operand\" or \"attributeName: lowerBound TO upperBound\"`\n        );\n      }\n\n      [match, field, value, operator, maxValue] = groups\n    }\n\n    const facetFilterMap = getFacetFilterMap(\n      config.facet_attributes || [],\n      config.filter_attributes || []\n    )\n    const facetFilterConfig = facetFilterMap[field]\n\n    const getFilter = (field: string, operator: string, value: string) => {\n      if (operator === '=') {\n        return {\n          term: {\n            [field]: value\n          }\n        }\n      } else if (operator === '!=') {\n        return {\n          bool: {\n            must_not: {\n              term: {\n                [field]: value\n              }\n            }\n          }\n        }\n      } else if (operator === '>') {\n        return {\n          range: {\n            [field]: {\n              gt: value\n            }\n          }\n        }\n      } else if (operator === '>=') {\n        return {\n          range: {\n            [field]: {\n              gte: value\n            }\n          }\n        }\n      } else if (operator === '<') {\n        return {\n          range: {\n            [field]: {\n              lt: value\n            }\n          }\n        }\n      } else if (operator === '<=') {\n        return {\n          range: {\n            [field]: {\n              lte: value\n            }\n          }\n        }\n      } else if (operator.toUpperCase() === 'TO') {\n        return {\n          range: {\n            [field]: {\n              gte: value,\n              lte: maxValue,\n            }\n          }\n        }\n      }\n    }\n\n    const esFilter = []\n\n    if (facetFilterConfig.nestedPath) {\n      const nestedPathPresent = sum.find((filter: any) => {\n        return filter.nested.path === facetFilterConfig.nestedPath\n      })\n\n      if (nestedPathPresent) {\n        nestedPathPresent.nested.query.bool.filter.push(\n          getFilter(facetFilterConfig.nestedPath + '.' + facetFilterConfig.field, operator, value)\n        )\n      } else {\n        esFilter.push({\n          nested: {\n            path: facetFilterConfig.nestedPath,\n            inner_hits: {},\n            query: {\n              bool: {\n                filter: [\n                  getFilter(\n                    facetFilterConfig.nestedPath + '.' + facetFilterConfig.field,\n                    operator,\n                    value\n                  )\n                ]\n              }\n            }\n          }\n        })\n      }\n    } else {\n      esFilter.push(getFilter(facetFilterConfig.field, operator, value))\n    }\n\n    return [...sum, ...esFilter]\n  }, [])\n}\n\nconst getFacetFilterMap = (facets: FacetAttribute[], filters: FilterAttribute[]) => {\n  return [...filters, ...facets].reduce<Record<string, FacetFieldConfig | FilterAttribute>>(\n    (sum, filter) => {\n      let f: FacetFieldConfig | FilterAttribute =\n        typeof filter === 'string' ? { attribute: filter, field: filter, type: 'string' } : filter\n\n      return {\n        ...sum,\n        [f.attribute]: f\n      }\n    },\n    {}\n  )\n}\n\nexport const transformFacetFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n): ElasticsearchQuery[] => {\n  const { params = {} } = request\n  const { facetFilters } = params\n\n  if (!Array.isArray(facetFilters)) {\n    return []\n  }\n\n  const facetFilterMap = getFacetFilterMap(\n    config.facet_attributes || [],\n    config.filter_attributes || []\n  )\n\n  return facetFilters.reduce((sum, filter) => {\n    if (Array.isArray(filter)) {\n      return [\n        ...sum,\n        {\n          bool: {\n            should: filter.reduce((sum, filter) => {\n              const [facet, value] = filter.split(':')\n              const facetFilterConfig = facetFilterMap[facet]\n              if (!facetFilterConfig)\n                throw new Error(\n                  `Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`\n                )\n              const field = facetFilterConfig.field\n              const filterClauseFn = facetFilterConfig.filterQuery || TermFilter\n\n              if (isNestedFacet(facetFilterConfig)) {\n                // detect if there is a nested filter in sum\n                // if one doesn't exist, add one\n                // if one does exist, add to it\n                const nestedFilter = sum.find((filter: any) => {\n                  return filter.nested && filter.nested.path === facetFilterConfig.nestedPath\n                })\n\n                if (nestedFilter) {\n                  nestedFilter.nested.query.bool.should.push(\n                    filterClauseFn(\n                      `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                      value\n                    )\n                  )\n                  return sum\n                } else {\n                  return [\n                    ...sum,\n                    {\n                      nested: {\n                        inner_hits: {},\n                        path: facetFilterConfig.nestedPath,\n                        query: {\n                          bool: {\n                            should: [\n                              filterClauseFn(\n                                `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                                value\n                              )\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n              return [...sum, filterClauseFn(field, value)]\n            }, [])\n          }\n        }\n      ]\n    } else if (typeof filter === 'string') {\n      const [facet, value] = filter.split(':')\n\n      const facetFilterConfig = facetFilterMap[facet]\n      if (!facetFilterConfig)\n        throw new Error(\n          `Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`\n        )\n\n      const filterClauseFn = facetFilterConfig.filterQuery || TermFilter\n\n      if (isNestedFacet(facetFilterConfig) && facetFilterConfig.nestedPath) {\n        // detect if there is a nested filter in sum\n        // if one doesn't exist, add one\n        // if one does exist, add to it\n        const nestedFilter = sum.find((filter: any) => {\n          return filter.nested && filter.nested.path === facetFilterConfig.nestedPath + '.'\n        })\n\n        if (nestedFilter) {\n          nestedFilter.nested.query.bool.should.push(\n            filterClauseFn(`${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`, value)\n          )\n          return sum\n        } else {\n          return [\n            ...sum,\n            {\n              nested: {\n                inner_hits: {},\n                path: facetFilterConfig.nestedPath,\n                query: {\n                  bool: {\n                    should: [\n                      filterClauseFn(\n                        `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                        value\n                      )\n                    ]\n                  }\n                }\n              }\n            }\n          ]\n        }\n      }\n      return [...sum, filterClauseFn(facetFilterConfig.field, value)]\n    }\n  }, [])\n}\n\nexport const transformQueryString = (\n  facets: FacetAttribute[] = [],\n  filters: FilterAttribute[] = [],\n  queryString: string\n) => {\n  const regex = /([\\w\\.\\-]+)\\:/gi\n  const filterMap = getFacetFilterMap(facets, filters)\n  return queryString.replace(regex, (match: string, word: string) => {\n    if (!filterMap[word]) {\n      throw new Error(\n        `Attribute \"${word}\" is not defined as an attribute in the facet or filter search settings`\n      )\n    }\n\n    if (!!filterMap[word].nestedPath) {\n      throw new Error(\n        `Attribute \"${word}\" is a nested field and cannot be used as a filter. Nested fields are supported in facetFilers or numericFilters.`\n      )\n    }\n\n    return filterMap[word].field + ':'\n  })\n}\n\nexport const transformBaseFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { filters } = params\n\n  if (!filters || filters === '') {\n    return []\n  }\n\n  const queryString = transformQueryString(\n    config.facet_attributes,\n    config.filter_attributes,\n    filters\n  )\n\n  return [\n    {\n      query_string: {\n        query: queryString\n      }\n    }\n  ]\n}\n\nexport const transformGeoFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  if (!config.geo_attribute) {\n    return []\n  }\n  const { params = {} } = request\n  const { aroundLatLng, aroundRadius, insideBoundingBox } = params\n\n  if (insideBoundingBox) {\n    return [insideBoundingBoxFilter(insideBoundingBox, config.geo_attribute)]\n  }\n\n  if (aroundLatLng) {\n    const geoPoint = aroundLatLng.split(',')\n\n    return [\n      {\n        geo_distance: {\n          distance: aroundRadius || '1000m',\n          [config.geo_attribute]: {\n            lat: geoPoint[0],\n            lon: geoPoint[1]\n          }\n        }\n      }\n    ]\n  }\n\n  return []\n}\n\nfunction insideBoundingBoxFilter(\n  insideBoundingBox: string | readonly (readonly number[])[],\n  field: string\n) {\n  const geoBoundingboxFilter = (top: number, left: number, bottom: number, right: number) => {\n    return {\n      geo_bounding_box: {\n        [field]: {\n          top_right: {\n            lat: top,\n            lon: left\n          },\n          bottom_left: {\n            lat: bottom,\n            lon: right\n          }\n        }\n      }\n    }\n  }\n\n  if (typeof insideBoundingBox === 'string') {\n    const [top, left, bottom, right] = insideBoundingBox.split(',')\n    return geoBoundingboxFilter(\n      parseFloat(top),\n      parseFloat(left),\n      parseFloat(bottom),\n      parseFloat(right)\n    )\n  } else if (Array.isArray(insideBoundingBox)) {\n    const geoBoundingboxes = insideBoundingBox.map((boundingBox) => {\n      const [top, left, bottom, right] = boundingBox\n      return geoBoundingboxFilter(\n        parseFloat(top),\n        parseFloat(left),\n        parseFloat(bottom),\n        parseFloat(right)\n      )\n    })\n\n    return {\n      bool: {\n        should: geoBoundingboxes\n      }\n    }\n  }\n}\n","import { SearchSettingsConfig } from './types'\nimport { AlgoliaMultipleQueriesQuery } from './types'\n\nexport function getSorting(request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find((key) => {\n      if (request.indexName.endsWith(key)) {\n        return true\n      }\n    })\n\n    if (!selectedSorting && !config.sorting.default) return {}\n\n    const sortOption = selectedSorting ? config.sorting[selectedSorting] : config.sorting.default\n\n    if (Array.isArray(sortOption)) {\n      return {\n        sort: sortOption.map((sorting) => {\n          return {\n            [sorting.field]: sorting.order\n          }\n        })\n      }\n    } else {\n      return {\n        sort: {\n          [sortOption.field]: sortOption.order\n        }\n      }\n    }\n  }\n  return {}\n}\n\nexport function getIndexName(indexName: string, config: SearchSettingsConfig) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find((key) => {\n      if (indexName.endsWith(key)) {\n        return true\n      }\n    })\n\n    if (selectedSorting) {\n      return indexName.replace(selectedSorting, '')\n    }\n  }\n  return indexName\n}\n","import { getSnippetFieldLength } from './transformRequest'\nimport type { ElasticsearchHit, SearchSettingsConfig } from './types'\n\nexport function highlightTerm(value: string, query: string): string {\n  const regex = new RegExp(query, 'gi')\n  return value.replace(regex, (match) => `<em>${match}</em>`)\n}\n\nexport function isAllowableHighlightField(\n  fieldKey: string,\n  highlightFields: string[]\n) {\n  return highlightFields.findIndex((highlightField) => {\n    if (highlightField.indexOf('*') < 0) {\n      return highlightField === fieldKey;\n    }\n\n    const safeHighlightField = highlightField.replace(/[.+?^$|\\{\\}\\(\\)\\[\\]\\\\]/g, '\\\\$&');\n    const regex = new RegExp(`^${safeHighlightField.replace(/\\*/g, '.*')}$`);\n    return regex.test(fieldKey);\n  }) >= 0;\n}\n\nexport function getHighlightFields(\n  hit: ElasticsearchHit,\n  preTag: string = '<ais-highlight-0000000000>',\n  postTag: string = '<ais-highlight-0000000000/>',\n  fields: SearchSettingsConfig['snippet_attributes'] = []\n) {\n  const { _source = {}, highlight = {} } = hit\n\n  const combinedKeys = {\n    ..._source,\n    ...highlight\n  }\n\n  const highlightFields = fields.map((field) => getSnippetFieldLength(field).attribute)\n\n  const hitHighlights = Object.keys(combinedKeys).reduce<Record<string, any>>((sum, fieldKey) => {\n    const fieldValue: any = _source[fieldKey]\n    const highlightedMatch = highlight[fieldKey] || null\n\n    if (!isAllowableHighlightField(fieldKey, highlightFields)) {\n      return sum\n    }\n    // no matches, specified as a highlight and value is an array\n    if (Array.isArray(fieldValue) && !highlightedMatch) {\n      return {\n        ...sum,\n        [fieldKey]: fieldValue.map((value) => ({\n          matchLevel: 'none',\n          matchedWords: [],\n          value: value.toString()\n        }))\n      }\n      // field array and has multiple highlighted matches\n    } else if (Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) {\n      return {\n        ...sum,\n        [fieldKey]: highlightedMatch.map((highlightedMatch) => {\n          const matchWords = Array.from(highlightedMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(\n            (match) => match[1]\n          )\n          return {\n            fullyHighlighted: false,\n            matchLevel: 'full',\n            matchedWords: matchWords,\n            value: highlightedMatch\n              .toString()\n              .replace(/\\<em\\>/g, preTag)\n              .replace(/\\<\\/em\\>/g, postTag)\n          }\n        })\n      }\n    } else if (\n      (!Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) ||\n      (!fieldValue && Array.isArray(highlightedMatch) && highlightedMatch.length > 0)\n    ) {\n      const singleMatch = highlightedMatch[0]\n\n      const matchWords = Array.from(singleMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(\n        (match) => match[1]\n      )\n      const x = {\n        fullyHighlighted: false,\n        matchLevel: 'full',\n        matchedWords: matchWords,\n        value: singleMatch\n          .toString()\n          .replace(/\\<em\\>/g, preTag)\n          .replace(/\\<\\/em\\>/g, postTag)\n      }\n\n      return {\n        ...sum,\n        [fieldKey]: x\n      }\n    }\n\n    return {\n      ...sum,\n      [fieldKey]: {\n        matchLevel: 'none',\n        matchedWords: [],\n        value: fieldValue != undefined ? fieldValue.toString() : ''\n      }\n    }\n  }, {})\n\n  return hitHighlights\n}\n","import { SearchSettingsConfig } from './types'\nimport { getHighlightFields, highlightTerm } from './highlightUtils'\nimport { AlgoliaMultipleQueriesQuery, ElasticsearchResponseBody } from './types'\nimport { getFacetFieldType } from './utils'\nimport { QueryRuleActions } from './queryRules'\nimport type { AggregationsStatsAggregate, GeoLocation } from '@elastic/elasticsearch/lib/api/types'\n\ntype FacetsList = Record<string, Record<string, number>>\ntype FacetsStats = Record<\n  string,\n  { min: number | null; max: number | null; avg: number | null; sum: number | null }\n>\n\nconst getHits = (\n  response: ElasticsearchResponseBody,\n  config: SearchSettingsConfig,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery\n) => {\n  const { hits } = response\n  const { highlight_attributes = [], snippet_attributes = [] } = config\n\n  return hits.hits.map((hit) => ({\n    objectID: hit._id,\n    _index: hit?._index,\n    ...(hit._source || {}),\n    ...(hit.fields || {}), // for runtime_mapping fields\n    ...(hit.inner_hits ? { inner_hits: hit.inner_hits } : {}),\n    ...(highlight_attributes.length > 0\n      ? {\n          _highlightResult: getHighlightFields(\n            hit,\n            instantsearchRequest?.params?.highlightPreTag,\n            instantsearchRequest?.params?.highlightPostTag,\n            highlight_attributes\n          )\n        }\n      : {}),\n    ...(snippet_attributes.length > 0\n      ? {\n          _snippetResult: getHighlightFields(\n            hit,\n            instantsearchRequest?.params?.highlightPreTag,\n            instantsearchRequest?.params?.highlightPostTag,\n            config.snippet_attributes\n          )\n        }\n      : {}),\n    ...(config.geo_attribute && hit._source?.[config.geo_attribute]\n      ? { _geoloc: convertLatLng(hit._source?.[config.geo_attribute] as GeoLocation) }\n      : {})\n  }))\n}\n\nfunction convertLatLng(value: GeoLocation) {\n  if (typeof value === 'string') {\n    const [lat, lng] = value.split(',').map((v) => parseFloat(v))\n    return { lat, lng }\n  } else if (Array.isArray(value)) {\n    return { lat: value[0], lng: value[1] }\n  } else if (typeof value === 'object') {\n    if ('lat' in value && 'lon' in value) {\n      return {\n        lat: parseFloat(value.lat as unknown as string),\n        lng: parseFloat(value.lon as unknown as string)\n      }\n    }\n  }\n  return null\n}\n\nconst getFacets = (response: ElasticsearchResponseBody, config: SearchSettingsConfig) => {\n  if (!response?.aggregations) {\n    return {}\n  }\n\n  // flattening for nested facets\n  const aggregations = Object.keys(response.aggregations).reduce<Record<string, any>>(\n    (sum, key) => {\n      const value = (response.aggregations || {})[key] as any\n\n      if (key.endsWith('.')) {\n        const { doc_count, ...nestedAggregations } = value\n        return {\n          ...sum,\n          ...nestedAggregations\n        }\n      }\n\n      return {\n        ...sum,\n        [key]: value\n      }\n    },\n    {}\n  )\n\n  return Object.keys(aggregations).reduce<{\n    facets: FacetsList\n    facets_stats: FacetsStats\n  }>(\n    (sum, f) => {\n      const facet = f.split('$')[0]\n      const fieldType = getFacetFieldType(config.facet_attributes || [], facet)\n\n      if (fieldType === 'numeric') {\n        const facetValues = aggregations[facet + '$_stats'] as AggregationsStatsAggregate\n        const { buckets } = aggregations[facet + '$_entries'] as {\n          buckets: any[]\n        }\n\n        return {\n          ...sum,\n          facets: {\n            ...sum.facets,\n            [facet]: buckets.reduce<Record<string, number>>(\n              (sum, bucket) => ({\n                ...sum,\n                [bucket.key]: bucket.doc_count\n              }),\n              {}\n            )\n          },\n          facets_stats: {\n            ...sum.facets_stats,\n            [facet]: {\n              min: facetValues.min,\n              avg: facetValues.avg,\n              max: facetValues.max,\n              sum: facetValues.sum\n            }\n          }\n        }\n      }\n\n      const { buckets } = aggregations[facet] as { buckets: any[] }\n\n      return {\n        ...sum,\n        facets: {\n          ...sum.facets,\n          [facet]: buckets.reduce<Record<string, number>>(\n            (sum, bucket) => ({\n              ...sum,\n              [bucket.key]: bucket.doc_count\n            }),\n            {}\n          )\n        }\n      }\n    },\n    {\n      facets: {},\n      facets_stats: {}\n    }\n  )\n}\n\nconst getRenderingContent = (config: SearchSettingsConfig, queryRuleActions: QueryRuleActions) => {\n  const defaultOrder = config.facet_attributes?.map((facet) =>\n    typeof facet === 'string' ? facet : facet.attribute\n  )\n\n  return {\n    renderingContent: {\n      facetOrdering: {\n        facets: {\n          order: queryRuleActions.facetAttributesOrder || defaultOrder || []\n        },\n        values: config.facet_attributes?.reduce<Record<string, { sortRemainingBy: 'count' }>>(\n          (sum, facet) => {\n            const facetName = typeof facet === 'string' ? facet : facet.attribute\n\n            // If request has explicit facet orders and the facet is not\n            // in the query rule actions, we don't want to sort it\n            if (\n              queryRuleActions.facetAttributesOrder &&\n              !queryRuleActions.facetAttributesOrder.includes(facetName)\n            ) {\n              return sum\n            }\n\n            return {\n              ...sum,\n              [facetName]: {\n                sortRemainingBy: 'count'\n              }\n            }\n          },\n          {}\n        )\n      }\n    }\n  }\n}\n\nconst getPageDetails = (\n  response: ElasticsearchResponseBody,\n  request: AlgoliaMultipleQueriesQuery,\n  queryRuleActions: QueryRuleActions\n) => {\n  const { params = {} } = request\n  const { hitsPerPage = 20, page = 0 } = params\n\n  const { total } = response.hits\n  const totalHits = typeof total === 'number' ? total : total?.value\n  const nbPages =\n    hitsPerPage <= 0\n      ? 0\n      : Math.ceil((typeof total === 'number' ? total : total?.value || 0) / hitsPerPage)\n\n  return {\n    hitsPerPage,\n    processingTimeMS: response.took,\n    nbHits: totalHits,\n    page: page,\n    nbPages,\n    query: queryRuleActions.query\n  }\n}\n\nexport default function transformResponse(\n  response: ElasticsearchResponseBody,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions\n) {\n  try {\n    return {\n      appliedRules: queryRuleActions.ruleIds,\n      exhaustiveNbHits: true,\n      exhaustiveFacetsCount: true,\n      exhaustiveTypo: true,\n      exhaustive: { facetsCount: true, nbHits: true, typo: true },\n      ...getPageDetails(response, instantsearchRequest, queryRuleActions),\n      ...getRenderingContent(config, queryRuleActions),\n      ...getFacets(response, config),\n      hits: getHits(response, config, instantsearchRequest),\n      index: instantsearchRequest.indexName,\n      params: new URLSearchParams(instantsearchRequest.params as any).toString(),\n      ...(queryRuleActions.userData.length > 0 ? { userData: queryRuleActions.userData } : {})\n    }\n  } catch (e) {\n    throw new Error(`Error transforming Elasticsearch response for index`)\n  }\n}\n\nexport const transformFacetValuesResponse = (\n  response: ElasticsearchResponseBody,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery\n) => {\n  const aggregations = response.aggregations || {}\n  // @ts-ignore\n  const facetName = instantsearchRequest?.params?.facetName\n\n  const preTag = instantsearchRequest.params?.highlightPreTag || '<ais-highlight-0000000000>'\n  const postTag = instantsearchRequest.params?.highlightPostTag || '<ais-highlight-0000000000/>'\n\n  let agg = aggregations[Object.keys(aggregations)[0]] as any\n\n  if (agg && agg[facetName]) {\n    agg = agg[facetName]\n  }\n\n  return {\n    facetHits: agg.buckets.map((entry: any) => ({\n      value: entry.key,\n      highlighted: highlightTerm(\n        entry.key,\n        // @ts-ignore\n        instantsearchRequest.params.facetQuery || ''\n      )\n        .replace(/<\\em>/g, preTag)\n        .replace(/<\\/\\em>/g, postTag),\n      count: entry.doc_count\n    })),\n    exhaustiveFacetsCount: true,\n    processingTimeMS: response.took\n  }\n}\n","import { AppSettings, BasicAuth, ConfigConnection, SearchRequest } from './types'\nimport { ElasticsearchResponseBody, Transporter } from './types'\nimport { createElasticsearchQueryFromRequest } from './utils'\n\nconst authString = (auth: BasicAuth) => {\n  if (typeof btoa === 'undefined') {\n    return Buffer.from(auth.username + ':' + auth.password).toString('base64')\n  } else {\n    return btoa(auth.username + ':' + auth.password)\n  }\n}\n\nfunction getHostFromCloud(cloudId: string) {\n  // the cloud id is `cluster-name:base64encodedurl`\n  // the url is a string divided by two '$', the first is the cloud url\n  // the second the elasticsearch instance, the third the kibana instance\n  let cloudUrls\n  if (typeof atob === 'undefined') {\n    cloudUrls = Buffer.from(cloudId.split(':')[1], 'base64').toString()\n  } else {\n    cloudUrls = atob(cloudId.split(':')[1]).split('$')\n  }\n  return `https://${cloudUrls[1]}.${cloudUrls[0]}`\n}\n\nexport class ESTransporter implements Transporter {\n  constructor(public config: ConfigConnection, private settings: AppSettings) {}\n\n  createElasticsearchQueryFromRequest(requests: SearchRequest[]) {\n    return createElasticsearchQueryFromRequest(requests)\n  }\n\n  async performNetworkRequest(requests: SearchRequest[]) {\n    if (this.config.host === undefined && this.config.cloud_id === undefined) {\n      throw new Error(\n        'No Elasticsearch host or cloud_id specified. Please provide a host or cloud id in your Searchkit configuration.'\n      )\n    }\n\n    const host = this.config.cloud_id ? getHostFromCloud(this.config.cloud_id) : this.config.host\n\n    return fetch(`${host}/_msearch`, {\n      headers: {\n        ...(this.config.apiKey ? { authorization: `ApiKey ${this.config.apiKey}` } : {}),\n        'content-type': 'application/json',\n        ...(this.config.headers || {}),\n        ...(this.config.auth\n          ? {\n              Authorization: 'Basic ' + authString(this.config.auth)\n            }\n          : {})\n      },\n      body: this.createElasticsearchQueryFromRequest(requests),\n      method: 'POST'\n    })\n  }\n\n  async msearch(requests: SearchRequest[]): Promise<ElasticsearchResponseBody[]> {\n    try {\n      const response = await this.performNetworkRequest(requests)\n      const responses = await response.json()\n\n      if (this.settings.debug) {\n        console.log('Elasticsearch response:')\n        console.log(JSON.stringify(responses))\n      }\n\n      if (responses.status >= 500) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Elasticsearch Internal Error: Check your elasticsearch instance to make sure it can recieve requests.'\n        )\n      } else if (responses.status === 401) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Cannot connect to Elasticsearch. Check your connection host and auth details (username/password or API Key required). You can also provide a custom Elasticsearch transporter to the API Client. See https://www.searchkit.co/docs/guides/setup-elasticsearch#connecting-with-usernamepassword for more details.'\n        )\n      } else if (responses.responses?.[0]?.status === 403) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Auth Error: You do not have permission to access this index. Check you are calling the right index (specified in frontend) and your API Key permissions has access to the index.'\n        )\n      } else if (responses.status === 404 || responses.responses?.[0]?.status === 404) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Elasticsearch index not found. Check your index name and make sure it exists.'\n        )\n      } else if (responses.status === 400 || responses.responses?.[0]?.status === 400) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          `Elasticsearch Bad Request. \n          \n          1. Check your query and make sure it is valid. \n          2. Check the field mapping. See documentation to make sure you are using text types for searching and keyword fields for faceting\n          3. Turn on debug mode to see the Elasticsearch query and the error response.\n          `\n        )\n      }\n      return responses.responses\n    } catch (error) {\n      throw error\n    }\n  }\n}\n","import { transformQueryString } from './filters'\nimport { AlgoliaMultipleQueriesQuery, QueryRule, SearchSettingsConfig } from './types'\n\nexport interface QueryContextFilter {\n  attribute: string\n  value: string\n}\n\nexport interface QueryContext {\n  query: string\n  context: readonly string[]\n  filters: readonly QueryContextFilter[]\n}\n\nexport interface QueryRuleActions {\n  ruleIds: string[]\n  pinnedDocs: string[]\n  boostFunctions: any[]\n  query: string\n  userData: unknown[]\n  facetAttributesOrder: string[] | undefined\n  baseFilters: any[]\n  touched: boolean\n}\n\nconst getFacetFilters = (\n  facetFilters: string | readonly string[] | readonly (string | readonly string[])[] | undefined\n): QueryContextFilter[] => {\n  if (!facetFilters) {\n    return []\n  }\n  if (typeof facetFilters === 'string') {\n    const [attribute, value] = facetFilters.split(':')\n    return [{ attribute, value }]\n  } else {\n    // @ts-ignore\n    return facetFilters.reduce<QueryContextFilter[]>((sum: any, filter: any) => {\n      if (typeof filter === 'string') {\n        const [attribute, value] = filter.split(':')\n        return [...sum, { attribute, value }]\n      }\n      return [...sum, ...getFacetFilters(filter)]\n    }, [])\n  }\n}\n\nexport const getQueryRulesActionsFromRequest = (\n  queryRules: QueryRule[],\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const queryContext: QueryContext = {\n    query: request.params?.query || '',\n    context: request.params?.ruleContexts || [],\n    filters: getFacetFilters(request.params?.facetFilters)\n  }\n\n  const satisfiedRules = getSatisfiedRules(queryContext, queryRules || [])\n\n  const actions = satisfiedRules.reduce<QueryRuleActions>(\n    (sum, rule) => {\n      rule.actions.map((action) => {\n        sum.touched = true\n        if (action.action === 'PinnedResult') {\n          sum.pinnedDocs.push(...action.documentIds)\n        } else if (action.action === 'QueryRewrite') {\n          sum.query = action.query\n        } else if (action.action === 'QueryBoost') {\n          sum.boostFunctions.push({\n            filter: {\n              query_string: {\n                query: transformQueryString(\n                  config.facet_attributes,\n                  config.filter_attributes,\n                  action.query\n                )\n              }\n            },\n            weight: action.weight\n          })\n        } else if (action.action === 'RenderUserData') {\n          sum.userData.push(JSON.parse(action.userData))\n        } else if (action.action === 'RenderFacetsOrder') {\n          sum.facetAttributesOrder = action.facetAttributesOrder\n        } else if (action.action === 'QueryFilter') {\n          sum.baseFilters.push({\n            query_string: {\n              query: transformQueryString(\n                config.facet_attributes,\n                config.filter_attributes,\n                action.query\n              )\n            }\n          })\n        }\n      })\n      return sum\n    },\n    {\n      ruleIds: satisfiedRules.map((rule) => rule.id),\n      pinnedDocs: [],\n      boostFunctions: [],\n      query: queryContext.query,\n      userData: [],\n      facetAttributesOrder: undefined,\n      touched: false,\n      baseFilters: []\n    }\n  )\n\n  return actions\n}\n\nexport const getSatisfiedRules = (queryContext: QueryContext, rules: QueryRule[]) =>\n  rules.filter(\n    (ruleOrs) =>\n      ruleOrs.conditions.find(\n        (rule) =>\n          rule.filter((condition) => {\n            if (condition.context === 'query' && condition.match_type === 'exact') {\n              return condition.value === queryContext.query\n            }\n            if (condition.context === 'query' && condition.match_type === 'contains') {\n              return queryContext.query.includes(condition.value)\n            }\n            if (condition.context === 'query' && condition.match_type === 'prefix') {\n              return queryContext.query.startsWith(condition.value)\n            }\n            if (condition.context === 'context') {\n              return condition.value.some((value) => queryContext.context.includes(value))\n            }\n            if (condition.context === 'filterPresent') {\n              return condition.values.every(\n                (value) =>\n                  queryContext.filters.find(\n                    (filter) => filter.attribute === value.attribute && filter.value === value.value\n                  ) !== undefined\n              )\n            }\n\n            return false\n          }).length === rule.length\n      ) !== undefined\n  )\n","import type { MultipleQueriesQuery as AlgoliaMultipleQueriesQuery } from '@algolia/client-search'\nimport { transformRequest } from './transformRequest'\nimport transformResponse, { transformFacetValuesResponse } from './transformResponse'\nimport { SearchkitConfig, SearchRequest, RequestOptions, Transporter, AppSettings } from './types'\nimport { ESTransporter } from './Transporter'\nimport { getQueryRulesActionsFromRequest, QueryRuleActions } from './queryRules'\nimport { createElasticsearchQueryFromRequest } from './utils'\nimport { getIndexName } from './sorting'\nexport * from './types'\nexport * from './Transporter'\nexport * from './filterUtils'\n\nexport default class Searchkit {\n  private transporter: Transporter\n\n  constructor(private config: SearchkitConfig, private settings: AppSettings = { debug: false }) {\n    this.transporter =\n      'msearch' in config.connection\n        ? config.connection\n        : new ESTransporter(config.connection, settings)\n  }\n\n  private async performSearch(requests: SearchRequest[]) {\n    try {\n      if (this.settings.debug) {\n        console.log('Performing search with requests:')\n        console.log('POST /_msearch')\n        console.log(createElasticsearchQueryFromRequest(requests))\n      }\n      const responses = await this.transporter.msearch(requests)\n      return responses\n    } catch (err) {\n      console.error(err)\n      return []\n    }\n  }\n\n  async handleInstantSearchRequests(\n    instantsearchRequests: readonly AlgoliaMultipleQueriesQuery[],\n    requestOptions?: RequestOptions\n  ) {\n    if (!instantsearchRequests || Array.isArray(instantsearchRequests) === false) {\n      console.log({ instantsearchRequests })\n      throw new Error(\n        'No instantsearch requests provided. Check that the data you are providing from API request is correct. Likely you are not passing the request body correctly, its still a JSON string or the API is not a POST request.'\n      )\n    }\n\n    const queryRules = this.config.search_settings.query_rules || []\n\n    const requestQueryRuleActions: QueryRuleActions[] = instantsearchRequests.map((request) => {\n      return getQueryRulesActionsFromRequest(queryRules, request, this.config.search_settings)\n    })\n\n    let esRequests: SearchRequest[] = instantsearchRequests.map((request, i) => ({\n      body: transformRequest(\n        request,\n        this.config.search_settings,\n        requestQueryRuleActions[i],\n        requestOptions\n      ),\n      request: request,\n      indexName: getIndexName(request.indexName, this.config.search_settings)\n    }))\n\n    if (requestOptions?.hooks?.beforeSearch) {\n      esRequests = await requestOptions.hooks.beforeSearch(esRequests)\n    }\n\n    let esResponses = await this.performSearch(esRequests)\n\n    if (requestOptions?.hooks?.afterSearch) {\n      esResponses = await requestOptions.hooks.afterSearch(esRequests, esResponses)\n    }\n\n    try {\n      const instantsearchResponses = esResponses.map((response, i) => {\n        // @ts-ignore\n        if (instantsearchRequests[i].params?.facetName) {\n          return transformFacetValuesResponse(response, instantsearchRequests[i])\n        }\n        return transformResponse(\n          response,\n          instantsearchRequests[i],\n          this.config.search_settings,\n          requestQueryRuleActions[i]\n        )\n      })\n\n      return {\n        results: instantsearchResponses\n      }\n    } catch (err) {\n      console.error(err)\n      throw new Error(\n        'Error transforming response. Check the afterSearch hook function is correct. Likely you are not returning the correct response object.'\n      )\n    }\n  }\n}\n"],"mappings":";AAKA,OAAOA,SAAA,MAAe;;;ACLf,IAAMC,UAAA,GAAaA,CAACC,KAAA,EAAeC,KAAA,KAAkB;EAC1D,OAAO;IAAEC,IAAA,EAAM;MAAE,CAACF,KAAA,GAAQC;IAAM;EAAE;AACpC;AAEO,IAAME,WAAA,GAAcA,CAACH,KAAA,EAAeC,KAAA,KAAkB;EAC3D,OAAO;IAAEG,KAAA,EAAO;MAAE,CAACJ,KAAA,GAAQC;IAAM;EAAE;AACrC;;;ACcO,IAAMI,QAAA,GAAWA,CACtBC,gBAAA,EACAC,aAAA,KAC0B;EAC1B,MAAMC,CAAA,GAAIF,gBAAA,CAAiBG,IAAA,CAAMC,CAAA,IAAM;IACrC,IAAI,OAAOA,CAAA,KAAM,UAAU;MACzB,OAAOA,CAAA,KAAMH,aAAA;IACf;IACA,OAAOG,CAAA,CAAEC,SAAA,KAAcJ,aAAA;EACzB,CAAC;EACD,OAAOC,CAAA,IAAK;AACd;AAEO,IAAMI,aAAA,GAAiBC,KAAA,IAAmC;EAC/D,OAAO,OAAOA,KAAA,KAAU,YAAY,CAAC,CAACA,KAAA,CAAMC,UAAA;AAC9C;AAsCO,IAAMC,iBAAA,GAAoBA,CAC/BT,gBAAA,EACAK,SAAA,KAC6B;EA5E/B,IAAAK,EAAA;EA6EE,MAAMC,YAAA,GAAe,OAAON,SAAA,KAAc,WAAWA,SAAA,GAAYA,SAAA,CAAUA,SAAA;EAE3E,IAAIL,gBAAA,CAAiBY,QAAA,CAASD,YAAY,GAAG;IAC3C,OAAO;EACT;EACA,SACED,EAAA,GAAAV,gBAAA,CAEGG,IAAA,CAAMC,CAAA,KAAMA,CAAA,oBAAAA,CAAA,CAAGC,SAAA,MAAcM,YAAY,MAF5C,gBAAAD,EAAA,CAE+CG,IAAA,KAAQ;AAE3D;AAEO,IAAMC,mCAAA,GAAuCC,QAAA,IAA8B;EAChF,OAAOA,QAAA,CACJC,MAAA,CACC,CAACC,GAAA,EAAKC,OAAA,KAAY,CAChB,GAAGD,GAAA,EACHE,IAAA,CAAKC,SAAA,CAAU;IAAEC,KAAA,EAAOH,OAAA,CAAQI;EAAU,CAAC,GAC3C,MACAH,IAAA,CAAKC,SAAA,CAAUF,OAAA,CAAQK,IAAI,GAC3B,KACF,EACA,EACF,EACCC,IAAA,CAAK,EAAE;AACZ;;;AC3FO,IAAMC,uBAAA,GAA0BA,CACrCP,OAAA,EACAQ,MAAA,KACyB;EACzB,MAAM;IAAEC,MAAA,GAAS,CAAC;EAAE,IAAIT,OAAA;EACxB,MAAM;IAAEU;EAAe,IAAID,MAAA;EAE3B,IAAI,CAACE,KAAA,CAAMC,OAAA,CAAQF,cAAc,GAAG;IAClC,OAAO,EAAC;EACV;EAEA,OAAOA,cAAA,CAAeZ,MAAA,CAAO,CAACC,GAAA,EAAKc,MAAA,KAAmB;IACpD,IAAIjC,KAAA;MAAOJ,KAAA;MAAOsC,QAAA;MAAUrC,KAAA;MAAOsC,QAAA,GAAW;IAC9C,IAAIC,MAAA,GAASH,MAAA,CAAOjC,KAAA,CAClB,qDACF;IAEA,IAAIoC,MAAA,EAAQ;MACV,CAACpC,KAAA,EAAOJ,KAAA,EAAOsC,QAAA,EAAUrC,KAAK,IAAIuC,MAAA;IACpC,OACK;MAEHA,MAAA,GAASH,MAAA,CAAOjC,KAAA,CACd,iDACF;MAEA,IAAI,CAACoC,MAAA,EAAQ;QACX,MAAM,IAAIC,KAAA,CACR,mBAAmBJ,MAAA,wIACrB;MACF;MAEA,CAACjC,KAAA,EAAOJ,KAAA,EAAOC,KAAA,EAAOqC,QAAA,EAAUC,QAAQ,IAAIC,MAAA;IAC9C;IAEA,MAAME,cAAA,GAAiBC,iBAAA,CACrBX,MAAA,CAAO1B,gBAAA,IAAoB,EAAC,EAC5B0B,MAAA,CAAOY,iBAAA,IAAqB,EAC9B;IACA,MAAMC,iBAAA,GAAoBH,cAAA,CAAe1C,KAAA;IAEzC,MAAM8C,SAAA,GAAYA,CAACC,MAAA,EAAeC,SAAA,EAAkBC,MAAA,KAAkB;MACpE,IAAID,SAAA,KAAa,KAAK;QACpB,OAAO;UACL9C,IAAA,EAAM;YACJ,CAAC6C,MAAA,GAAQE;UACX;QACF;MACF,WAAWD,SAAA,KAAa,MAAM;QAC5B,OAAO;UACLE,IAAA,EAAM;YACJC,QAAA,EAAU;cACRjD,IAAA,EAAM;gBACJ,CAAC6C,MAAA,GAAQE;cACX;YACF;UACF;QACF;MACF,WAAWD,SAAA,KAAa,KAAK;QAC3B,OAAO;UACLI,KAAA,EAAO;YACL,CAACL,MAAA,GAAQ;cACPM,EAAA,EAAIJ;YACN;UACF;QACF;MACF,WAAWD,SAAA,KAAa,MAAM;QAC5B,OAAO;UACLI,KAAA,EAAO;YACL,CAACL,MAAA,GAAQ;cACPO,GAAA,EAAKL;YACP;UACF;QACF;MACF,WAAWD,SAAA,KAAa,KAAK;QAC3B,OAAO;UACLI,KAAA,EAAO;YACL,CAACL,MAAA,GAAQ;cACPQ,EAAA,EAAIN;YACN;UACF;QACF;MACF,WAAWD,SAAA,KAAa,MAAM;QAC5B,OAAO;UACLI,KAAA,EAAO;YACL,CAACL,MAAA,GAAQ;cACPS,GAAA,EAAKP;YACP;UACF;QACF;MACF,WAAWD,SAAA,CAASS,WAAA,CAAY,MAAM,MAAM;QAC1C,OAAO;UACLL,KAAA,EAAO;YACL,CAACL,MAAA,GAAQ;cACPO,GAAA,EAAKL,MAAA;cACLO,GAAA,EAAKjB;YACP;UACF;QACF;MACF;IACF;IAEA,MAAMmB,QAAA,GAAW,EAAC;IAElB,IAAIb,iBAAA,CAAkB/B,UAAA,EAAY;MAChC,MAAM6C,iBAAA,GAAoBpC,GAAA,CAAId,IAAA,CAAMmD,OAAA,IAAgB;QAClD,OAAOA,OAAA,CAAOC,MAAA,CAAOC,IAAA,KAASjB,iBAAA,CAAkB/B,UAAA;MAClD,CAAC;MAED,IAAI6C,iBAAA,EAAmB;QACrBA,iBAAA,CAAkBE,MAAA,CAAOE,KAAA,CAAMb,IAAA,CAAKb,MAAA,CAAO2B,IAAA,CACzClB,SAAA,CAAUD,iBAAA,CAAkB/B,UAAA,GAAa,MAAM+B,iBAAA,CAAkB7C,KAAA,EAAOsC,QAAA,EAAUrC,KAAK,CACzF;MACF,OAAO;QACLyD,QAAA,CAASM,IAAA,CAAK;UACZH,MAAA,EAAQ;YACNC,IAAA,EAAMjB,iBAAA,CAAkB/B,UAAA;YACxBmD,UAAA,EAAY,CAAC;YACbF,KAAA,EAAO;cACLb,IAAA,EAAM;gBACJb,MAAA,EAAQ,CACNS,SAAA,CACED,iBAAA,CAAkB/B,UAAA,GAAa,MAAM+B,iBAAA,CAAkB7C,KAAA,EACvDsC,QAAA,EACArC,KACF;cAEJ;YACF;UACF;QACF,CAAC;MACH;IACF,OAAO;MACLyD,QAAA,CAASM,IAAA,CAAKlB,SAAA,CAAUD,iBAAA,CAAkB7C,KAAA,EAAOsC,QAAA,EAAUrC,KAAK,CAAC;IACnE;IAEA,OAAO,CAAC,GAAGsB,GAAA,EAAK,GAAGmC,QAAQ;EAC7B,GAAG,EAAE;AACP;AAEA,IAAMf,iBAAA,GAAoBA,CAACuB,MAAA,EAA0BC,OAAA,KAA+B;EAClF,OAAO,CAAC,GAAGA,OAAA,EAAS,GAAGD,MAAM,EAAE5C,MAAA,CAC7B,CAACC,GAAA,EAAKc,MAAA,KAAW;IACf,IAAI7B,CAAA,GACF,OAAO6B,MAAA,KAAW,WAAW;MAAE1B,SAAA,EAAW0B,MAAA;MAAQrC,KAAA,EAAOqC,MAAA;MAAQlB,IAAA,EAAM;IAAS,IAAIkB,MAAA;IAEtF,OAAO;MACL,GAAGd,GAAA;MACH,CAACf,CAAA,CAAEG,SAAA,GAAYH;IACjB;EACF,GACA,CAAC,CACH;AACF;AAEO,IAAM4D,qBAAA,GAAwBA,CACnC5C,OAAA,EACAQ,MAAA,KACyB;EACzB,MAAM;IAAEC,MAAA,GAAS,CAAC;EAAE,IAAIT,OAAA;EACxB,MAAM;IAAE6C;EAAa,IAAIpC,MAAA;EAEzB,IAAI,CAACE,KAAA,CAAMC,OAAA,CAAQiC,YAAY,GAAG;IAChC,OAAO,EAAC;EACV;EAEA,MAAM3B,cAAA,GAAiBC,iBAAA,CACrBX,MAAA,CAAO1B,gBAAA,IAAoB,EAAC,EAC5B0B,MAAA,CAAOY,iBAAA,IAAqB,EAC9B;EAEA,OAAOyB,YAAA,CAAa/C,MAAA,CAAO,CAACC,GAAA,EAAKc,MAAA,KAAW;IAC1C,IAAIF,KAAA,CAAMC,OAAA,CAAQC,MAAM,GAAG;MACzB,OAAO,CACL,GAAGd,GAAA,EACH;QACE2B,IAAA,EAAM;UACJoB,MAAA,EAAQjC,MAAA,CAAOf,MAAA,CAAO,CAACiD,IAAA,EAAKX,OAAA,KAAW;YACrC,MAAM,CAAC/C,KAAA,EAAOZ,KAAK,IAAI2D,OAAA,CAAOY,KAAA,CAAM,GAAG;YACvC,MAAM3B,iBAAA,GAAoBH,cAAA,CAAe7B,KAAA;YACzC,IAAI,CAACgC,iBAAA,EACH,MAAM,IAAIJ,KAAA,CACR,UAAU5B,KAAA,kGACZ;YACF,MAAMb,KAAA,GAAQ6C,iBAAA,CAAkB7C,KAAA;YAChC,MAAMyE,cAAA,GAAiB5B,iBAAA,CAAkB6B,WAAA,IAAe3E,UAAA;YAExD,IAAIa,aAAA,CAAciC,iBAAiB,GAAG;cAIpC,MAAM8B,YAAA,GAAeJ,IAAA,CAAI9D,IAAA,CAAMmE,OAAA,IAAgB;gBAC7C,OAAOA,OAAA,CAAOf,MAAA,IAAUe,OAAA,CAAOf,MAAA,CAAOC,IAAA,KAASjB,iBAAA,CAAkB/B,UAAA;cACnE,CAAC;cAED,IAAI6D,YAAA,EAAc;gBAChBA,YAAA,CAAad,MAAA,CAAOE,KAAA,CAAMb,IAAA,CAAKoB,MAAA,CAAON,IAAA,CACpCS,cAAA,CACE,GAAG5B,iBAAA,CAAkB/B,UAAA,IAAc+B,iBAAA,CAAkB7C,KAAA,IACrDC,KACF,CACF;gBACA,OAAOsE,IAAA;cACT,OAAO;gBACL,OAAO,CACL,GAAGA,IAAA,EACH;kBACEV,MAAA,EAAQ;oBACNI,UAAA,EAAY,CAAC;oBACbH,IAAA,EAAMjB,iBAAA,CAAkB/B,UAAA;oBACxBiD,KAAA,EAAO;sBACLb,IAAA,EAAM;wBACJoB,MAAA,EAAQ,CACNG,cAAA,CACE,GAAG5B,iBAAA,CAAkB/B,UAAA,IAAc+B,iBAAA,CAAkB7C,KAAA,IACrDC,KACF;sBAEJ;oBACF;kBACF;gBACF,EACF;cACF;YACF;YACA,OAAO,CAAC,GAAGsE,IAAA,EAAKE,cAAA,CAAezE,KAAA,EAAOC,KAAK,CAAC;UAC9C,GAAG,EAAE;QACP;MACF,EACF;IACF,WAAW,OAAOoC,MAAA,KAAW,UAAU;MACrC,MAAM,CAACxB,KAAA,EAAOZ,KAAK,IAAIoC,MAAA,CAAOmC,KAAA,CAAM,GAAG;MAEvC,MAAM3B,iBAAA,GAAoBH,cAAA,CAAe7B,KAAA;MACzC,IAAI,CAACgC,iBAAA,EACH,MAAM,IAAIJ,KAAA,CACR,UAAU5B,KAAA,kGACZ;MAEF,MAAM4D,cAAA,GAAiB5B,iBAAA,CAAkB6B,WAAA,IAAe3E,UAAA;MAExD,IAAIa,aAAA,CAAciC,iBAAiB,KAAKA,iBAAA,CAAkB/B,UAAA,EAAY;QAIpE,MAAM6D,YAAA,GAAepD,GAAA,CAAId,IAAA,CAAMmD,OAAA,IAAgB;UAC7C,OAAOA,OAAA,CAAOC,MAAA,IAAUD,OAAA,CAAOC,MAAA,CAAOC,IAAA,KAASjB,iBAAA,CAAkB/B,UAAA,GAAa;QAChF,CAAC;QAED,IAAI6D,YAAA,EAAc;UAChBA,YAAA,CAAad,MAAA,CAAOE,KAAA,CAAMb,IAAA,CAAKoB,MAAA,CAAON,IAAA,CACpCS,cAAA,CAAe,GAAG5B,iBAAA,CAAkB/B,UAAA,IAAc+B,iBAAA,CAAkB7C,KAAA,IAASC,KAAK,CACpF;UACA,OAAOsB,GAAA;QACT,OAAO;UACL,OAAO,CACL,GAAGA,GAAA,EACH;YACEsC,MAAA,EAAQ;cACNI,UAAA,EAAY,CAAC;cACbH,IAAA,EAAMjB,iBAAA,CAAkB/B,UAAA;cACxBiD,KAAA,EAAO;gBACLb,IAAA,EAAM;kBACJoB,MAAA,EAAQ,CACNG,cAAA,CACE,GAAG5B,iBAAA,CAAkB/B,UAAA,IAAc+B,iBAAA,CAAkB7C,KAAA,IACrDC,KACF;gBAEJ;cACF;YACF;UACF,EACF;QACF;MACF;MACA,OAAO,CAAC,GAAGsB,GAAA,EAAKkD,cAAA,CAAe5B,iBAAA,CAAkB7C,KAAA,EAAOC,KAAK,CAAC;IAChE;EACF,GAAG,EAAE;AACP;AAEO,IAAM4E,oBAAA,GAAuBA,CAClCX,MAAA,GAA2B,EAAC,EAC5BC,OAAA,GAA6B,EAAC,EAC9BW,WAAA,KACG;EACH,MAAMC,KAAA,GAAQ;EACd,MAAMC,SAAA,GAAYrC,iBAAA,CAAkBuB,MAAA,EAAQC,OAAO;EACnD,OAAOW,WAAA,CAAYG,OAAA,CAAQF,KAAA,EAAO,CAAC3E,KAAA,EAAe8E,IAAA,KAAiB;IACjE,IAAI,CAACF,SAAA,CAAUE,IAAA,GAAO;MACpB,MAAM,IAAIzC,KAAA,CACR,cAAcyC,IAAA,yEAChB;IACF;IAEA,IAAI,CAAC,CAACF,SAAA,CAAUE,IAAA,EAAMpE,UAAA,EAAY;MAChC,MAAM,IAAI2B,KAAA,CACR,cAAcyC,IAAA,mHAChB;IACF;IAEA,OAAOF,SAAA,CAAUE,IAAA,EAAMlF,KAAA,GAAQ;EACjC,CAAC;AACH;AAEO,IAAMmF,oBAAA,GAAuBA,CAClC3D,OAAA,EACAQ,MAAA,KACG;EACH,MAAM;IAAEC,MAAA,GAAS,CAAC;EAAE,IAAIT,OAAA;EACxB,MAAM;IAAE2C;EAAQ,IAAIlC,MAAA;EAEpB,IAAI,CAACkC,OAAA,IAAWA,OAAA,KAAY,IAAI;IAC9B,OAAO,EAAC;EACV;EAEA,MAAMW,WAAA,GAAcD,oBAAA,CAClB7C,MAAA,CAAO1B,gBAAA,EACP0B,MAAA,CAAOY,iBAAA,EACPuB,OACF;EAEA,OAAO,CACL;IACEiB,YAAA,EAAc;MACZrB,KAAA,EAAOe;IACT;EACF,EACF;AACF;AAEO,IAAMO,mBAAA,GAAsBA,CACjC7D,OAAA,EACAQ,MAAA,KACG;EACH,IAAI,CAACA,MAAA,CAAOsD,aAAA,EAAe;IACzB,OAAO,EAAC;EACV;EACA,MAAM;IAAErD,MAAA,GAAS,CAAC;EAAE,IAAIT,OAAA;EACxB,MAAM;IAAE+D,YAAA;IAAcC,YAAA;IAAcC;EAAkB,IAAIxD,MAAA;EAE1D,IAAIwD,iBAAA,EAAmB;IACrB,OAAO,CAACC,uBAAA,CAAwBD,iBAAA,EAAmBzD,MAAA,CAAOsD,aAAa,CAAC;EAC1E;EAEA,IAAIC,YAAA,EAAc;IAChB,MAAMI,QAAA,GAAWJ,YAAA,CAAaf,KAAA,CAAM,GAAG;IAEvC,OAAO,CACL;MACEoB,YAAA,EAAc;QACZC,QAAA,EAAUL,YAAA,IAAgB;QAC1B,CAACxD,MAAA,CAAOsD,aAAA,GAAgB;UACtBQ,GAAA,EAAKH,QAAA,CAAS;UACdI,GAAA,EAAKJ,QAAA,CAAS;QAChB;MACF;IACF,EACF;EACF;EAEA,OAAO,EAAC;AACV;AAEA,SAASD,wBACPD,iBAAA,EACAzF,KAAA,EACA;EACA,MAAMgG,oBAAA,GAAuBA,CAACC,GAAA,EAAaC,IAAA,EAAcC,MAAA,EAAgBC,KAAA,KAAkB;IACzF,OAAO;MACLC,gBAAA,EAAkB;QAChB,CAACrG,KAAA,GAAQ;UACPsG,SAAA,EAAW;YACTR,GAAA,EAAKG,GAAA;YACLF,GAAA,EAAKG;UACP;UACAK,WAAA,EAAa;YACXT,GAAA,EAAKK,MAAA;YACLJ,GAAA,EAAKK;UACP;QACF;MACF;IACF;EACF;EAEA,IAAI,OAAOX,iBAAA,KAAsB,UAAU;IACzC,MAAM,CAACQ,GAAA,EAAKC,IAAA,EAAMC,MAAA,EAAQC,KAAK,IAAIX,iBAAA,CAAkBjB,KAAA,CAAM,GAAG;IAC9D,OAAOwB,oBAAA,CACLQ,UAAA,CAAWP,GAAG,GACdO,UAAA,CAAWN,IAAI,GACfM,UAAA,CAAWL,MAAM,GACjBK,UAAA,CAAWJ,KAAK,CAClB;EACF,WAAWjE,KAAA,CAAMC,OAAA,CAAQqD,iBAAiB,GAAG;IAC3C,MAAMgB,gBAAA,GAAmBhB,iBAAA,CAAkBiB,GAAA,CAAKC,WAAA,IAAgB;MAC9D,MAAM,CAACV,GAAA,EAAKC,IAAA,EAAMC,MAAA,EAAQC,KAAK,IAAIO,WAAA;MACnC,OAAOX,oBAAA,CACLQ,UAAA,CAAWP,GAAG,GACdO,UAAA,CAAWN,IAAI,GACfM,UAAA,CAAWL,MAAM,GACjBK,UAAA,CAAWJ,KAAK,CAClB;IACF,CAAC;IAED,OAAO;MACLlD,IAAA,EAAM;QACJoB,MAAA,EAAQmC;MACV;IACF;EACF;AACF;;;AClaO,SAASG,WAAWpF,OAAA,EAAsCQ,MAAA,EAA8B;EAC7F,IAAIA,MAAA,CAAO6E,OAAA,IAAWC,MAAA,CAAOC,IAAA,CAAK/E,MAAA,CAAO6E,OAAO,EAAEG,MAAA,GAAS,GAAG;IAC5D,MAAMC,eAAA,GAAkBH,MAAA,CAAOC,IAAA,CAAK/E,MAAA,CAAO6E,OAAO,EAAEpG,IAAA,CAAMyG,GAAA,IAAQ;MAChE,IAAI1F,OAAA,CAAQI,SAAA,CAAUuF,QAAA,CAASD,GAAG,GAAG;QACnC,OAAO;MACT;IACF,CAAC;IAED,IAAI,CAACD,eAAA,IAAmB,CAACjF,MAAA,CAAO6E,OAAA,CAAQO,OAAA,EAAS,OAAO,CAAC;IAEzD,MAAMC,UAAA,GAAaJ,eAAA,GAAkBjF,MAAA,CAAO6E,OAAA,CAAQI,eAAA,IAAmBjF,MAAA,CAAO6E,OAAA,CAAQO,OAAA;IAEtF,IAAIjF,KAAA,CAAMC,OAAA,CAAQiF,UAAU,GAAG;MAC7B,OAAO;QACLC,IAAA,EAAMD,UAAA,CAAWX,GAAA,CAAKG,OAAA,IAAY;UAChC,OAAO;YACL,CAACA,OAAA,CAAQ7G,KAAA,GAAQ6G,OAAA,CAAQU;UAC3B;QACF,CAAC;MACH;IACF,OAAO;MACL,OAAO;QACLD,IAAA,EAAM;UACJ,CAACD,UAAA,CAAWrH,KAAA,GAAQqH,UAAA,CAAWE;QACjC;MACF;IACF;EACF;EACA,OAAO,CAAC;AACV;AAEO,SAASC,aAAa5F,SAAA,EAAmBI,MAAA,EAA8B;EAC5E,IAAIA,MAAA,CAAO6E,OAAA,IAAWC,MAAA,CAAOC,IAAA,CAAK/E,MAAA,CAAO6E,OAAO,EAAEG,MAAA,GAAS,GAAG;IAC5D,MAAMC,eAAA,GAAkBH,MAAA,CAAOC,IAAA,CAAK/E,MAAA,CAAO6E,OAAO,EAAEpG,IAAA,CAAMyG,GAAA,IAAQ;MAChE,IAAItF,SAAA,CAAUuF,QAAA,CAASD,GAAG,GAAG;QAC3B,OAAO;MACT;IACF,CAAC;IAED,IAAID,eAAA,EAAiB;MACnB,OAAOrF,SAAA,CAAUqD,OAAA,CAAQgC,eAAA,EAAiB,EAAE;IAC9C;EACF;EACA,OAAOrF,SAAA;AACT;;;AJvBO,IAAM6F,gBAAA,GAAoB3C,WAAA,IAAwB;EACvD,IAAIf,KAAA,GAAQe,WAAA,CAAYG,OAAA,CAAQ,uCAAuC,MAAM;EAC7ElB,KAAA,GAAQA,KAAA,CACLS,KAAA,CAAM,EAAE,EACRkC,GAAA,CAAKgB,IAAA,IAAS;IACb,IAAI,QAAQC,IAAA,CAAKD,IAAI,GAAG;MACtB,OAAO,IAAIA,IAAA,GAAOA,IAAA,CAAKjE,WAAA,CAAY;IACrC;IACA,OAAOiE,IAAA;EACT,CAAC,EACA5F,IAAA,CAAK,EAAE;EACViC,KAAA,GAAQ,GAAGA,KAAA;EACX,IAAIe,WAAA,CAAYkC,MAAA,GAAS,GAAG;IAC1BjD,KAAA,GAAQ,iBAAiBA,KAAA;EAC3B;EACA,OAAOA,KAAA;AACT;AAEA,IAAM6D,eAAA,GAAkBA,CAAC5H,KAAA,EAAe6H,IAAA,EAAcC,MAAA,KAAmB;EACvE,MAAMC,aAAA,GAAgBD,MAAA,IAAUA,MAAA,CAAOd,MAAA,GAAS,IAAI;IAAEgB,OAAA,EAASP,gBAAA,CAAiBK,MAAM;EAAE,IAAI,CAAC;EAC7F,OAAO;IACLG,KAAA,EAAO;MACLjI,KAAA;MACA6H,IAAA;MACA,GAAGE;IACL;EACF;AACF;AAEA,IAAMG,kBAAA,GAAqBA,CAACrH,KAAA,EAAuBgH,IAAA,EAAcC,MAAA,KAAmB;EAClF,IAAIK,UAAA,GAAa,CAAC;EAClB,MAAMC,aAAA,GACJ,OAAOvH,KAAA,KAAU,YAAYA,KAAA,CAAMwH,UAAA,GAAaxH,KAAA,CAAMwH,UAAA,GAAaT,eAAA;EAErE,MAAMU,YAAA,GAAeA,CAACC,SAAA,EAAmBvI,KAAA,KAAuB;IAC9D,IAAI,OAAOa,KAAA,KAAU,YAAYA,KAAA,CAAMM,IAAA,KAAS,UAAU;MACxDgH,UAAA,GAAa;QACX,CAACI,SAAA,GAAYH,aAAA,CAAcpI,KAAA,EAAO6H,IAAA,EAAMC,MAAM;MAChD;IACF,WAAWjH,KAAA,CAAMM,IAAA,KAAS,WAAW;MACnCgH,UAAA,GAAa;QACX,CAACI,SAAA,GAAY,YAAY;UACvBC,KAAA,EAAO;YACLxI;UACF;QACF;QACA,CAACuI,SAAA,GAAY,cAAcH,aAAA,CAAcpI,KAAA,EAAO6H,IAAA,EAAMC,MAAM;MAC9D;IACF;IACA,OAAOK,UAAA;EACT;EAEA,IAAI,OAAOtH,KAAA,KAAU,UAAU;IAC7B,OAAOyH,YAAA,CAAazH,KAAA,EAAOA,KAAK;EAClC,WAAWD,aAAA,CAAcC,KAAK,GAAG;IAC/B,OAAO;MACL,CAAC,GAAGA,KAAA,CAAMC,UAAA,MAAgB;QACxB+C,MAAA,EAAQ;UACNC,IAAA,EAAMjD,KAAA,CAAMC;QACd;QACA2H,IAAA,EAAMH,YAAA,CAAazH,KAAA,CAAMF,SAAA,EAAW,GAAGE,KAAA,CAAMC,UAAA,IAAcD,KAAA,CAAMb,KAAA,EAAO;MAC1E;IACF;EACF,OAAO;IACL,OAAOsI,YAAA,CAAazH,KAAA,CAAMF,SAAA,EAAWE,KAAA,CAAMb,KAAK;EAClD;AACF;AAEO,IAAM0I,OAAA,GAAUA,CACrBlH,OAAA,EACAQ,MAAA,EACA2G,gBAAA,KACG;EACH,MAAM;IAAE1G,MAAA,GAAS,CAAC;IAAGd;EAAK,IAAIK,OAAA;EAE9B,MAAM;IAAE0C,MAAA;IAAQ0E,iBAAA;IAAmBL,SAAA;IAAWF;EAAW,IAAIpG,MAAA;EAC7D,MAAM4G,YAAA,GAAeD,iBAAA,IAAqB;EAC1C,MAAME,eAAA,GAAkB9G,MAAA,CAAO1B,gBAAA,IAAoB,EAAC;EAEpD,IAAIiI,SAAA,EAAW;IACb,MAAM1H,KAAA,GAAQR,QAAA,CAASyI,eAAA,EAAiBP,SAAS;IACjD,IAAI,CAAC1H,KAAA,EAAO,OAAO;IACnB,OAAOqH,kBAAA,CAAmBrH,KAAA,EAAOgI,YAAA,EAAcR,UAAU;EAC3D,WAAWlG,KAAA,CAAMC,OAAA,CAAQ8B,MAAM,GAAG;IAChC,IAAI6E,cAAA,GAAiB/G,MAAA,CAAO1B,gBAAA,IAAoB,EAAC;IAEjD,IAAIqI,gBAAA,CAAiBK,oBAAA,EAAsB;MACzCD,cAAA,GAAiBJ,gBAAA,CAAiBK,oBAAA,CAC/BtC,GAAA,CAAK/F,SAAA,IAAc;QAClB,OAAON,QAAA,CAAS2B,MAAA,CAAO1B,gBAAA,IAAoB,EAAC,EAAGK,SAAS;MAC1D,CAAC,EACA0B,MAAA,CAAQ4G,CAAA,IAA2BA,CAAA,KAAM,IAAI;IAClD;IAEA,MAAMC,gBAAA,GACJhF,MAAA,CAAO,OAAO,MACV6E,cAAA,GACA7E,MAAA,CACGwC,GAAA,CAAKyC,cAAA,IAAmB;MACvB,OAAO9I,QAAA,CAAS2B,MAAA,CAAO1B,gBAAA,IAAoB,EAAC,EAAG6I,cAAc;IAC/D,CAAC,EACA9G,MAAA,CAAQ4G,CAAA,IAA2BA,CAAA,KAAM,IAAI;IAEtD,OACEC,gBAAA,CAAgB5H,MAAA,CAAO,CAACC,GAAA,EAAKV,KAAA,KAAU;MACrC,OAAOf,SAAA,CAAUyB,GAAA,EAAK2G,kBAAA,CAAmBrH,KAAA,EAAOgI,YAAA,EAAc,EAAE,CAAC;IACnE,GAAG,CAAC,CAAC,KAAK,CAAC;EAEf,WAAW,OAAO3E,MAAA,KAAW,UAAU;IACrC,MAAMlE,KAAA,GAAQK,QAAA,CAAS2B,MAAA,CAAO1B,gBAAA,IAAoB,EAAC,EAAG4D,MAAM;IAC5D,IAAI,CAAClE,KAAA,EAAO,OAAO,CAAC;IACpB,OAAOkI,kBAAA,CAAmBlI,KAAA,EAAO6I,YAAA,EAAc,EAAE;EACnD;AACF;AAEA,SAASO,kBAAkBC,YAAA,EAAmBV,gBAAA,EAAoC;EAChF,IAAIA,gBAAA,CAAiBW,OAAA,EAAS;IAC5B,OAAO;MACLC,cAAA,EAAgB;QACdxF,KAAA,EAAO;UACLyF,MAAA,EAAQ;YACNC,GAAA,EAAKd,gBAAA,CAAiBe,UAAA;YACtBC,OAAA,EAASN;UACX;QACF;QACAO,SAAA,EAAWjB,gBAAA,CAAiBkB;MAC9B;IACF;EACF;EACA,OAAOR,YAAA;AACT;AAEO,SAASS,oBAAoB/F,KAAA,EAAegG,iBAAA,EAAsC;EACvF,MAAMC,YAAA,GAAgBC,eAAA,IAA4B;IAChD,OAAOF,iBAAA,CAAkBrD,GAAA,CAAK/F,SAAA,IAAc;MAC1C,OAAO,OAAOA,SAAA,KAAc,WACxBA,SAAA,GACA,GAAGA,SAAA,CAAUX,KAAA,KAAUW,SAAA,CAAUuJ,MAAA,IAAU,KAAKD,eAAA;IACtD,CAAC;EACH;EAEA,OAAO;IACL/G,IAAA,EAAM;MACJoB,MAAA,EAAQ,CACN;QACEpB,IAAA,EAAM;UACJoB,MAAA,EAAQ,CACN;YACE6F,WAAA,EAAa;cACXpG,KAAA;cACAqG,MAAA,EAAQJ,YAAA,CAAa,CAAC;cACtBK,SAAA,EAAW;YACb;UACF,GACA;YACEF,WAAA,EAAa;cACXpG,KAAA;cACAqG,MAAA,EAAQJ,YAAA,CAAa,GAAG;cACxB7I,IAAA,EAAM;YACR;UACF;QAEJ;MACF,GACA;QACEgJ,WAAA,EAAa;UACXpG,KAAA;UACA5C,IAAA,EAAM;UACNiJ,MAAA,EAAQJ,YAAA,CAAa,CAAC;QACxB;MACF;IAEJ;EACF;AACF;AAEA,IAAMM,QAAA,GAAWA,CACf9I,OAAA,EACAQ,MAAA,EACA2G,gBAAA,EACA4B,cAAA,KACmF;EA7MrF,IAAAvJ,EAAA,EAAAwJ,EAAA,EAAAC,EAAA;EA8ME,MAAM1G,KAAA,GAAQ4E,gBAAA,CAAiB5E,KAAA;EAE/B,MAAM2G,gBAAA,GAAmB1I,MAAA,CAAO+H,iBAAA;EAEhC,MAAM5F,OAAA,GAAU,CACd,GAAGC,qBAAA,CAAsB5C,OAAA,EAASQ,MAAM,GACxC,GAAGD,uBAAA,CAAwBP,OAAA,EAASQ,MAAM,GAC1C,GAAGmD,oBAAA,CAAqB3D,OAAA,EAASQ,MAAM,GACvC,GAAGqD,mBAAA,CAAoB7D,OAAA,EAASQ,MAAM,GACtC,MAAIhB,EAAA,GAAAuJ,cAAA,oBAAAA,cAAA,CAAgBI,cAAA,KAAhB,gBAAA3J,EAAA,CAAA4J,IAAA,CAAAL,cAAA,MAAsC,EAAC,GAC3C,GAAG5B,gBAAA,CAAiBkC,WAAA,CACtB;EAEA,IAAIxB,YAAA,GACF,OAAOtF,KAAA,KAAU,YAAYA,KAAA,KAAU,MACnCwG,cAAA,oBAAAA,cAAA,CAAgBD,QAAA,IACdC,cAAA,CAAeD,QAAA,CAASvG,KAAA,EAAO2G,gBAAA,EAAkB1I,MAAM,IACvD8H,mBAAA,CAAoB/F,KAAA,EAAO2G,gBAAgB,IAC7C;IACEI,SAAA,EAAW,CAAC;EACd;EAEN,MAAMC,MAAA,GAAS,QAAOR,cAAA,oBAAAA,cAAA,CAAgBS,WAAA,MAAgB;EACtD,MAAMC,UAAA,KAAaT,EAAA,GAAAD,cAAA,oBAAAA,cAAA,CAAgBD,QAAA,KAAhB,gBAAAE,EAAA,CAAAI,IAAA,CAAAL,cAAA,EAA2BxG,KAAA,EAAO2G,gBAAA,EAAkB1I,MAAA,OAAY;EAEnF,IAAIiJ,UAAA,IAAeF,MAAA,IAAUhH,KAAA,KAAU,IAAK;IAC1CsF,YAAA,GAAe;MACbyB,SAAA,EAAW,CAAC;IACd;EACF;EAEA,MAAMI,QAAA,GAAW;IACfhI,IAAA,EAAM;MACJb,MAAA,EAAQ8B,OAAA;MACRgH,IAAA,EAAMxC,gBAAA,CAAiBW,OAAA,GACnBF,iBAAA,CAAkBC,YAAA,EAAcV,gBAAgB,IAChDU;IACN;EACF;EAEA,IAAI+B,WAAA,GAAqC;EAEzC,IAAIL,MAAA,IAAUhH,KAAA,KAAU,IAAI;IAC1BqH,WAAA,GAAc;MACZ/I,MAAA,EAAQ8B,OAAA;MACR,MAAIsG,EAAA,GAAAF,cAAA,oBAAAA,cAAA,CAAgBS,WAAA,KAAhB,gBAAAP,EAAA,CAAAG,IAAA,CAAAL,cAAA,EAA8BxG,KAAA,EAAO2G,gBAAA,EAAkB1I,MAAA,MAAW,CAAC;IACzE;EACF;EAEA,IAAI+B,KAAA,KAAU,MAAMkH,UAAA,IAAcF,MAAA,IAAUK,WAAA,EAAa;IACvD,OAAO;MACLC,GAAA,EAAKD;IACP;EACF;EAEA,MAAMvD,IAAA,GAAOyD,cAAA,CAAe9J,OAAO;EAEnC,OAAO;IACLuC,KAAA,EAAOmH,QAAA;IACPG,GAAA,EAAKD,WAAA,GAAcA,WAAA,GAAc;IAEjCG,IAAA,EACER,MAAA,IAAU,CAACE,UAAA,IAAcpD,IAAA,GAAO,KAAK9D,KAAA,KAAU,KAAK;MAAEyH,GAAA,EAAK;QAAEC,WAAA,EAAa5D;MAAK;IAAE,IAAI;EACzF;AACF;AAEA,IAAMyD,cAAA,GAAkB9J,OAAA,IAAyC;EAC/D,MAAM;IAAES,MAAA,GAAS,CAAC;EAAE,IAAIT,OAAA;EACxB,OAAOS,MAAA,CAAOyJ,WAAA,IAAe,OAAO,KAAKzJ,MAAA,CAAOyJ,WAAA;AAClD;AAEA,IAAMC,cAAA,GAAiBA,CAACnK,OAAA,EAAsCQ,MAAA,KAAiC;EAC7F,MAAM;IAAEC,MAAA,GAAS,CAAC;EAAE,IAAIT,OAAA;EACxB,MAAMkK,WAAA,GAAcJ,cAAA,CAAe9J,OAAO;EAE1C,OAAO;IACLqG,IAAA,EAAM6D,WAAA;IACNE,IAAA,GAAO3J,MAAA,CAAO4J,IAAA,IAAQ,KAAKH;EAC7B;AACF;AAEO,IAAMI,YAAA,GAAeA,CAC1BtK,OAAA,EACAQ,MAAA,KACG;EACH,MAAM;IAAEC,MAAA,GAAS,CAAC;EAAE,IAAIT,OAAA;EACxB,MAAM;IAAEuK;EAAqB,IAAI9J,MAAA;EAGjC,MAAM+J,YAAA,GAAe,mBAAIC,GAAA,CAAI,CAC3B,IAAIjK,MAAA,CAAOkK,iBAAA,IAAqB,EAAC,GACjC,IAAIlK,MAAA,CAAOmK,oBAAA,IAAwB,EAAC,GACpC,IAAInK,MAAA,CAAOsD,aAAA,GAAgB,CAACtD,MAAA,CAAOsD,aAAa,IAAI,EAAC,EACtD;EAED,MAAM8G,aAAA,GAAgBtF,MAAA,CAAOC,IAAA,CAAK/E,MAAA,CAAOqK,gBAAA,IAAoB,CAAC,CAAC;EAC/D,MAAMjC,MAAA,GAASgC,aAAA,CAAc9K,MAAA,CAAiB,CAACC,GAAA,EAAKvB,KAAA,KAAU;IA9ShE,IAAAgB,EAAA;IA+SI,KAAIA,EAAA,GAAAgB,MAAA,CAAOkK,iBAAA,KAAP,gBAAAlL,EAAA,CAA0BE,QAAA,CAASlB,KAAA,GAAQ;MAC7C,OAAO,CAACA,KAAA,EAAO,GAAGuB,GAAG;IACvB;IACA,OAAOA,GAAA;EACT,GAAG,EAAE;EAEL,OAAO;IACL+K,OAAA,EAAS;MACPpL,QAAA,EAAUiB,KAAA,CAAMyJ,IAAA,CAAKI,YAAY;IACnC;IACA,IAAI5B,MAAA,CAAOpD,MAAA,GAAS,IAAI;MAAEoD;IAAO,IAAI,CAAC;EACxC;AACF;AAEO,IAAMmC,qBAAA,GAAyB5L,SAAA,IAAsB;EAC1D,MAAM6L,YAAA,GAAe;IACnB7L,SAAA;IACAqG,MAAA,EAAQ;EACV;EACA,IAAI,CAACrG,SAAA,CAAUO,QAAA,CAAS,GAAG,GAAG;IAC5B,OAAOsL,YAAA;EACT;EACA,MAAMpM,KAAA,GAAQO,SAAA,CAAUP,KAAA,CAAM,aAAa;EAC3C,IAAI,CAACA,KAAA,EAAO,OAAOoM,YAAA;EACnB,OAAO;IACL7L,SAAA,EAAWP,KAAA,CAAM;IACjB4G,MAAA,EAAQyF,QAAA,CAASrM,KAAA,CAAM,EAAE;EAC3B;AACF;AAEO,IAAMsM,kBAAA,GAAqBA,CAChClL,OAAA,EACAQ,MAAA,KACG;EAhVL,IAAAhB,EAAA,EAAAwJ,EAAA;EAiVE,MAAM;IAAEvI,MAAA,GAAS,CAAC;EAAE,IAAIT,OAAA;EACxB,MAAM;IAAEmL;EAAsB,IAAI1K,MAAA;EAGlC,MAAM2K,eAAA,KACJ5L,EAAA,GAAAgB,MAAA,CAAOmK,oBAAA,KAAP,gBAAAnL,EAAA,CAA6BM,MAAA,CAC3B,CAACC,GAAA,EAAKvB,KAAA,MAAW;IACf,GAAGuB,GAAA;IACH,CAACvB,KAAA,GAAQ;MACP6M,mBAAA,EAAqB;IACvB;EACF,IACA,CAAC,OACE,CAAC;EAER,MAAMC,aAAA,KACJtC,EAAA,GAAAxI,MAAA,CAAO+K,kBAAA,KAAP,gBAAAvC,EAAA,CAA2BlJ,MAAA,CACzB,CAACC,GAAA,EAAKZ,SAAA,MAAe;IACnB,GAAGY,GAAA;IACH,CAACgL,qBAAA,CAAsB5L,SAAS,EAAEA,SAAA,GAAY;MAC5CkM,mBAAA,EAAqB;MACrBG,aAAA,EAAeT,qBAAA,CAAsB5L,SAAS,EAAEqG;IAClD;EACF,IACA,CAAC,OACE,CAAC;EAER,IAAIF,MAAA,CAAOC,IAAA,CAAK6F,eAAe,EAAE5F,MAAA,KAAW,KAAKF,MAAA,CAAOC,IAAA,CAAK+F,aAAa,EAAE9F,MAAA,KAAW,GAAG;IACxF,OAAO,CAAC;EACV;EAEA,OAAO;IACLiG,SAAA,EAAW;MACTC,QAAA,EAAU,CAAC,MAAM;MACjBC,SAAA,EAAW,CAAC,OAAO;MACnB/C,MAAA,EAAQ;QACN,GAAGwC,eAAA;QACH,GAAGE;MACL;IACF;EACF;AACF;AAEA,IAAMM,kBAAA,GAAqBA,CAAC5L,OAAA,EAAsCQ,MAAA,KAAiC;EACjG,IAAI,CAACA,MAAA,CAAOqK,gBAAA,EAAkB;IAC5B,OAAO,CAAC;EACV;EAEA,OAAO;IACLA,gBAAA,EAAkBrK,MAAA,CAAOqK;EAC3B;AACF;AAEO,SAASgB,iBACd7L,OAAA,EACAQ,MAAA,EACA2G,gBAAA,EACA4B,cAAA,EAC4B;EAC5B,MAAM1I,IAAA,GAAmC;IACvC4G,IAAA,EAAMC,OAAA,CAAQlH,OAAA,EAASQ,MAAA,EAAQ2G,gBAAgB;IAC/C,GAAG2B,QAAA,CAAS9I,OAAA,EAASQ,MAAA,EAAQ2G,gBAAA,EAAkB4B,cAAc;IAC7D,GAAGoB,cAAA,CAAenK,OAAA,EAASQ,MAAM;IACjC,GAAG8J,YAAA,CAAatK,OAAA,EAASQ,MAAM;IAC/B,GAAG0K,kBAAA,CAAmBlL,OAAA,EAASQ,MAAM;IACrC,GAAG4E,UAAA,CAAWpF,OAAA,EAASQ,MAAM;IAC7B,GAAGoL,kBAAA,CAAmB5L,OAAA,EAASQ,MAAM;EACvC;EAEA,OAAOH,IAAA;AACT;;;AKpZO,SAASyL,cAAcrN,KAAA,EAAe8D,KAAA,EAAuB;EAClE,MAAMgB,KAAA,GAAQ,IAAIwI,MAAA,CAAOxJ,KAAA,EAAO,IAAI;EACpC,OAAO9D,KAAA,CAAMgF,OAAA,CAAQF,KAAA,EAAQ3E,KAAA,IAAU,OAAOA,KAAA,OAAY;AAC5D;AAEO,SAASoN,0BACdC,QAAA,EACAb,eAAA,EACA;EACA,OAAOA,eAAA,CAAgBc,SAAA,CAAWC,cAAA,IAAmB;IACnD,IAAIA,cAAA,CAAeC,OAAA,CAAQ,GAAG,IAAI,GAAG;MACnC,OAAOD,cAAA,KAAmBF,QAAA;IAC5B;IAEA,MAAMI,kBAAA,GAAqBF,cAAA,CAAe1I,OAAA,CAAQ,2BAA2B,MAAM;IACnF,MAAMF,KAAA,GAAQ,IAAIwI,MAAA,CAAO,IAAIM,kBAAA,CAAmB5I,OAAA,CAAQ,OAAO,IAAI,IAAI;IACvE,OAAOF,KAAA,CAAM4C,IAAA,CAAK8F,QAAQ;EAC5B,CAAC,KAAK;AACR;AAEO,SAASK,oBACdC,GAAA,EACAC,MAAA,GAAiB,8BACjBC,OAAA,GAAkB,+BAClB7D,MAAA,GAAqD,EAAC,EACtD;EACA,MAAM;IAAEkC,OAAA,GAAU,CAAC;IAAGW,SAAA,GAAY,CAAC;EAAE,IAAIc,GAAA;EAEzC,MAAMG,YAAA,GAAe;IACnB,GAAG5B,OAAA;IACH,GAAGW;EACL;EAEA,MAAML,eAAA,GAAkBxC,MAAA,CAAO1D,GAAA,CAAK1G,KAAA,IAAUuM,qBAAA,CAAsBvM,KAAK,EAAEW,SAAS;EAEpF,MAAMwN,aAAA,GAAgBrH,MAAA,CAAOC,IAAA,CAAKmH,YAAY,EAAE5M,MAAA,CAA4B,CAACC,GAAA,EAAKkM,QAAA,KAAa;IAC7F,MAAMW,UAAA,GAAkB9B,OAAA,CAAQmB,QAAA;IAChC,MAAMY,gBAAA,GAAmBpB,SAAA,CAAUQ,QAAA,KAAa;IAEhD,IAAI,CAACD,yBAAA,CAA0BC,QAAA,EAAUb,eAAe,GAAG;MACzD,OAAOrL,GAAA;IACT;IAEA,IAAIY,KAAA,CAAMC,OAAA,CAAQgM,UAAU,KAAK,CAACC,gBAAA,EAAkB;MAClD,OAAO;QACL,GAAG9M,GAAA;QACH,CAACkM,QAAA,GAAWW,UAAA,CAAW1H,GAAA,CAAKzG,KAAA,KAAW;UACrCqO,UAAA,EAAY;UACZC,YAAA,EAAc,EAAC;UACftO,KAAA,EAAOA,KAAA,CAAMuO,QAAA,CAAS;QACxB,EAAE;MACJ;IAEF,WAAWrM,KAAA,CAAMC,OAAA,CAAQgM,UAAU,KAAKC,gBAAA,IAAoBlM,KAAA,CAAMC,OAAA,CAAQiM,gBAAgB,GAAG;MAC3F,OAAO;QACL,GAAG9M,GAAA;QACH,CAACkM,QAAA,GAAWY,gBAAA,CAAiB3H,GAAA,CAAK+H,iBAAA,IAAqB;UACrD,MAAMC,UAAA,GAAavM,KAAA,CAAMyJ,IAAA,CAAK6C,iBAAA,CAAiBE,QAAA,CAAS,sBAAsB,CAAC,EAAEjI,GAAA,CAC9EtG,KAAA,IAAUA,KAAA,CAAM,EACnB;UACA,OAAO;YACLwO,gBAAA,EAAkB;YAClBN,UAAA,EAAY;YACZC,YAAA,EAAcG,UAAA;YACdzO,KAAA,EAAOwO,iBAAA,CACJD,QAAA,CAAS,EACTvJ,OAAA,CAAQ,WAAW+I,MAAM,EACzB/I,OAAA,CAAQ,aAAagJ,OAAO;UACjC;QACF,CAAC;MACH;IACF,WACG,CAAC9L,KAAA,CAAMC,OAAA,CAAQgM,UAAU,KAAKC,gBAAA,IAAoBlM,KAAA,CAAMC,OAAA,CAAQiM,gBAAgB,KAChF,CAACD,UAAA,IAAcjM,KAAA,CAAMC,OAAA,CAAQiM,gBAAgB,KAAKA,gBAAA,CAAiBrH,MAAA,GAAS,GAC7E;MACA,MAAM6H,WAAA,GAAcR,gBAAA,CAAiB;MAErC,MAAMK,UAAA,GAAavM,KAAA,CAAMyJ,IAAA,CAAKiD,WAAA,CAAYF,QAAA,CAAS,sBAAsB,CAAC,EAAEjI,GAAA,CACzEtG,KAAA,IAAUA,KAAA,CAAM,EACnB;MACA,MAAM6I,CAAA,GAAI;QACR2F,gBAAA,EAAkB;QAClBN,UAAA,EAAY;QACZC,YAAA,EAAcG,UAAA;QACdzO,KAAA,EAAO4O,WAAA,CACJL,QAAA,CAAS,EACTvJ,OAAA,CAAQ,WAAW+I,MAAM,EACzB/I,OAAA,CAAQ,aAAagJ,OAAO;MACjC;MAEA,OAAO;QACL,GAAG1M,GAAA;QACH,CAACkM,QAAA,GAAWxE;MACd;IACF;IAEA,OAAO;MACL,GAAG1H,GAAA;MACH,CAACkM,QAAA,GAAW;QACVa,UAAA,EAAY;QACZC,YAAA,EAAc,EAAC;QACftO,KAAA,EAAOmO,UAAA,IAAc,SAAYA,UAAA,CAAWI,QAAA,CAAS,IAAI;MAC3D;IACF;EACF,GAAG,CAAC,CAAC;EAEL,OAAOL,aAAA;AACT;;;ACjGA,IAAMW,OAAA,GAAUA,CACdC,QAAA,EACA/M,MAAA,EACAgN,oBAAA,KACG;EACH,MAAM;IAAEC;EAAK,IAAIF,QAAA;EACjB,MAAM;IAAE5C,oBAAA,GAAuB,EAAC;IAAGY,kBAAA,GAAqB;EAAG,IAAI/K,MAAA;EAE/D,OAAOiN,IAAA,CAAKA,IAAA,CAAKvI,GAAA,CAAKqH,GAAA,IAAK;IArB7B,IAAA/M,EAAA,EAAAwJ,EAAA,EAAAC,EAAA,EAAAyE,EAAA,EAAAC,EAAA,EAAAC,EAAA;IAqBiC;MAC7BC,QAAA,EAAUtB,GAAA,CAAIuB,GAAA;MACdC,MAAA,EAAQxB,GAAA,oBAAAA,GAAA,CAAKwB,MAAA;MACb,IAAIxB,GAAA,CAAIzB,OAAA,IAAW,CAAC;MACpB,IAAIyB,GAAA,CAAI3D,MAAA,IAAU,CAAC;MACnB,IAAI2D,GAAA,CAAI9J,UAAA,GAAa;QAAEA,UAAA,EAAY8J,GAAA,CAAI9J;MAAW,IAAI,CAAC;MACvD,IAAIkI,oBAAA,CAAqBnF,MAAA,GAAS,IAC9B;QACEwI,gBAAA,EAAkB1B,mBAAA,CAChBC,GAAA,GACA/M,EAAA,GAAAgO,oBAAA,oBAAAA,oBAAA,CAAsB/M,MAAA,KAAtB,gBAAAjB,EAAA,CAA8ByO,eAAA,GAC9BjF,EAAA,GAAAwE,oBAAA,oBAAAA,oBAAA,CAAsB/M,MAAA,KAAtB,gBAAAuI,EAAA,CAA8BkF,gBAAA,EAC9BvD,oBACF;MACF,IACA,CAAC;MACL,IAAIY,kBAAA,CAAmB/F,MAAA,GAAS,IAC5B;QACE2I,cAAA,EAAgB7B,mBAAA,CACdC,GAAA,GACAtD,EAAA,GAAAuE,oBAAA,oBAAAA,oBAAA,CAAsB/M,MAAA,KAAtB,gBAAAwI,EAAA,CAA8BgF,eAAA,GAC9BP,EAAA,GAAAF,oBAAA,oBAAAA,oBAAA,CAAsB/M,MAAA,KAAtB,gBAAAiN,EAAA,CAA8BQ,gBAAA,EAC9B1N,MAAA,CAAO+K,kBACT;MACF,IACA,CAAC;MACL,IAAI/K,MAAA,CAAOsD,aAAA,MAAiB6J,EAAA,GAAApB,GAAA,CAAIzB,OAAA,KAAJ,gBAAA6C,EAAA,CAAcnN,MAAA,CAAOsD,aAAA,KAC7C;QAAEsK,OAAA,EAASC,aAAA,EAAcT,EAAA,GAAArB,GAAA,CAAIzB,OAAA,KAAJ,gBAAA8C,EAAA,CAAcpN,MAAA,CAAOsD,aAAA,CAA6B;MAAE,IAC7E,CAAC;IACP;EAAA,CAAE;AACJ;AAEA,SAASuK,cAAc5P,KAAA,EAAoB;EACzC,IAAI,OAAOA,KAAA,KAAU,UAAU;IAC7B,MAAM,CAAC6F,GAAA,EAAKgK,GAAG,IAAI7P,KAAA,CAAMuE,KAAA,CAAM,GAAG,EAAEkC,GAAA,CAAKqJ,CAAA,IAAMvJ,UAAA,CAAWuJ,CAAC,CAAC;IAC5D,OAAO;MAAEjK,GAAA;MAAKgK;IAAI;EACpB,WAAW3N,KAAA,CAAMC,OAAA,CAAQnC,KAAK,GAAG;IAC/B,OAAO;MAAE6F,GAAA,EAAK7F,KAAA,CAAM;MAAI6P,GAAA,EAAK7P,KAAA,CAAM;IAAG;EACxC,WAAW,OAAOA,KAAA,KAAU,UAAU;IACpC,IAAI,SAASA,KAAA,IAAS,SAASA,KAAA,EAAO;MACpC,OAAO;QACL6F,GAAA,EAAKU,UAAA,CAAWvG,KAAA,CAAM6F,GAAwB;QAC9CgK,GAAA,EAAKtJ,UAAA,CAAWvG,KAAA,CAAM8F,GAAwB;MAChD;IACF;EACF;EACA,OAAO;AACT;AAEA,IAAMiK,SAAA,GAAYA,CAACjB,QAAA,EAAqC/M,MAAA,KAAiC;EACvF,IAAI,EAAC+M,QAAA,oBAAAA,QAAA,CAAUkB,YAAA,GAAc;IAC3B,OAAO,CAAC;EACV;EAGA,MAAMA,YAAA,GAAenJ,MAAA,CAAOC,IAAA,CAAKgI,QAAA,CAASkB,YAAY,EAAE3O,MAAA,CACtD,CAACC,GAAA,EAAK2F,GAAA,KAAQ;IACZ,MAAMjH,KAAA,IAAS8O,QAAA,CAASkB,YAAA,IAAgB,CAAC,GAAG/I,GAAA;IAE5C,IAAIA,GAAA,CAAIC,QAAA,CAAS,GAAG,GAAG;MACrB,MAAM;QAAE+I,SAAA;QAAA,GAAcC;MAAmB,IAAIlQ,KAAA;MAC7C,OAAO;QACL,GAAGsB,GAAA;QACH,GAAG4O;MACL;IACF;IAEA,OAAO;MACL,GAAG5O,GAAA;MACH,CAAC2F,GAAA,GAAMjH;IACT;EACF,GACA,CAAC,CACH;EAEA,OAAO6G,MAAA,CAAOC,IAAA,CAAKkJ,YAAY,EAAE3O,MAAA,CAI/B,CAACC,GAAA,EAAKf,CAAA,KAAM;IACV,MAAMK,KAAA,GAAQL,CAAA,CAAEgE,KAAA,CAAM,GAAG,EAAE;IAC3B,MAAM4L,SAAA,GAAYrP,iBAAA,CAAkBiB,MAAA,CAAO1B,gBAAA,IAAoB,EAAC,EAAGO,KAAK;IAExE,IAAIuP,SAAA,KAAc,WAAW;MAC3B,MAAMC,WAAA,GAAcJ,YAAA,CAAapP,KAAA,GAAQ;MACzC,MAAM;QAAEyP,OAAA,EAAAC;MAAQ,IAAIN,YAAA,CAAapP,KAAA,GAAQ;MAIzC,OAAO;QACL,GAAGU,GAAA;QACH2C,MAAA,EAAQ;UACN,GAAG3C,GAAA,CAAI2C,MAAA;UACP,CAACrD,KAAA,GAAQ0P,QAAA,CAAQjP,MAAA,CACf,CAACiD,IAAA,EAAKiM,MAAA,MAAY;YAChB,GAAGjM,IAAA;YACH,CAACiM,MAAA,CAAOtJ,GAAA,GAAMsJ,MAAA,CAAON;UACvB,IACA,CAAC,CACH;QACF;QACAO,YAAA,EAAc;UACZ,GAAGlP,GAAA,CAAIkP,YAAA;UACP,CAAC5P,KAAA,GAAQ;YACP6P,GAAA,EAAKL,WAAA,CAAYK,GAAA;YACjBC,GAAA,EAAKN,WAAA,CAAYM,GAAA;YACjBC,GAAA,EAAKP,WAAA,CAAYO,GAAA;YACjBrP,GAAA,EAAK8O,WAAA,CAAY9O;UACnB;QACF;MACF;IACF;IAEA,MAAM;MAAE+O;IAAQ,IAAIL,YAAA,CAAapP,KAAA;IAEjC,OAAO;MACL,GAAGU,GAAA;MACH2C,MAAA,EAAQ;QACN,GAAG3C,GAAA,CAAI2C,MAAA;QACP,CAACrD,KAAA,GAAQyP,OAAA,CAAQhP,MAAA,CACf,CAACiD,IAAA,EAAKiM,MAAA,MAAY;UAChB,GAAGjM,IAAA;UACH,CAACiM,MAAA,CAAOtJ,GAAA,GAAMsJ,MAAA,CAAON;QACvB,IACA,CAAC,CACH;MACF;IACF;EACF,GACA;IACEhM,MAAA,EAAQ,CAAC;IACTuM,YAAA,EAAc,CAAC;EACjB,CACF;AACF;AAEA,IAAMI,mBAAA,GAAsBA,CAAC7O,MAAA,EAA8B2G,gBAAA,KAAuC;EA7JlG,IAAA3H,EAAA,EAAAwJ,EAAA;EA8JE,MAAMsG,YAAA,IAAe9P,EAAA,GAAAgB,MAAA,CAAO1B,gBAAA,KAAP,gBAAAU,EAAA,CAAyB0F,GAAA,CAAK7F,KAAA,IACjD,OAAOA,KAAA,KAAU,WAAWA,KAAA,GAAQA,KAAA,CAAMF,SAAA;EAG5C,OAAO;IACLoQ,gBAAA,EAAkB;MAChBC,aAAA,EAAe;QACb9M,MAAA,EAAQ;UACNqD,KAAA,EAAOoB,gBAAA,CAAiBK,oBAAA,IAAwB8H,YAAA,IAAgB;QAClE;QACAG,MAAA,GAAQzG,EAAA,GAAAxI,MAAA,CAAO1B,gBAAA,KAAP,gBAAAkK,EAAA,CAAyBlJ,MAAA,CAC/B,CAACC,GAAA,EAAKV,KAAA,KAAU;UACd,MAAM0H,SAAA,GAAY,OAAO1H,KAAA,KAAU,WAAWA,KAAA,GAAQA,KAAA,CAAMF,SAAA;UAI5D,IACEgI,gBAAA,CAAiBK,oBAAA,IACjB,CAACL,gBAAA,CAAiBK,oBAAA,CAAqB9H,QAAA,CAASqH,SAAS,GACzD;YACA,OAAOhH,GAAA;UACT;UAEA,OAAO;YACL,GAAGA,GAAA;YACH,CAACgH,SAAA,GAAY;cACX2I,eAAA,EAAiB;YACnB;UACF;QACF,GACA,CAAC;MAEL;IACF;EACF;AACF;AAEA,IAAMC,cAAA,GAAiBA,CACrBpC,QAAA,EACAvN,OAAA,EACAmH,gBAAA,KACG;EACH,MAAM;IAAE1G,MAAA,GAAS,CAAC;EAAE,IAAIT,OAAA;EACxB,MAAM;IAAEkK,WAAA,GAAc;IAAIG,IAAA,GAAO;EAAE,IAAI5J,MAAA;EAEvC,MAAM;IAAEmP;EAAM,IAAIrC,QAAA,CAASE,IAAA;EAC3B,MAAMoC,SAAA,GAAY,OAAOD,KAAA,KAAU,WAAWA,KAAA,GAAQA,KAAA,oBAAAA,KAAA,CAAOnR,KAAA;EAC7D,MAAMqR,OAAA,GACJ5F,WAAA,IAAe,IACX,IACA6F,IAAA,CAAKC,IAAA,EAAM,OAAOJ,KAAA,KAAU,WAAWA,KAAA,IAAQA,KAAA,oBAAAA,KAAA,CAAOnR,KAAA,KAAS,KAAKyL,WAAW;EAErF,OAAO;IACLA,WAAA;IACA+F,gBAAA,EAAkB1C,QAAA,CAAS2C,IAAA;IAC3BC,MAAA,EAAQN,SAAA;IACRxF,IAAA;IACAyF,OAAA;IACAvN,KAAA,EAAO4E,gBAAA,CAAiB5E;EAC1B;AACF;AAEe,SAAR6N,kBACL7C,QAAA,EACAC,oBAAA,EACAhN,MAAA,EACA2G,gBAAA,EACA;EACA,IAAI;IACF,OAAO;MACLkJ,YAAA,EAAclJ,gBAAA,CAAiBmJ,OAAA;MAC/BC,gBAAA,EAAkB;MAClBC,qBAAA,EAAuB;MACvBC,cAAA,EAAgB;MAChBC,UAAA,EAAY;QAAEC,WAAA,EAAa;QAAMR,MAAA,EAAQ;QAAMS,IAAA,EAAM;MAAK;MAC1D,GAAGjB,cAAA,CAAepC,QAAA,EAAUC,oBAAA,EAAsBrG,gBAAgB;MAClE,GAAGkI,mBAAA,CAAoB7O,MAAA,EAAQ2G,gBAAgB;MAC/C,GAAGqH,SAAA,CAAUjB,QAAA,EAAU/M,MAAM;MAC7BiN,IAAA,EAAMH,OAAA,CAAQC,QAAA,EAAU/M,MAAA,EAAQgN,oBAAoB;MACpDrN,KAAA,EAAOqN,oBAAA,CAAqBpN,SAAA;MAC5BK,MAAA,EAAQ,IAAIoQ,eAAA,CAAgBrD,oBAAA,CAAqB/M,MAAa,EAAEuM,QAAA,CAAS;MACzE,IAAI7F,gBAAA,CAAiB2J,QAAA,CAAStL,MAAA,GAAS,IAAI;QAAEsL,QAAA,EAAU3J,gBAAA,CAAiB2J;MAAS,IAAI,CAAC;IACxF;EACF,SAASC,CAAA,EAAP;IACA,MAAM,IAAI9P,KAAA,CAAM,qDAAqD;EACvE;AACF;AAEO,IAAM+P,4BAAA,GAA+BA,CAC1CzD,QAAA,EACAC,oBAAA,KACG;EAzPL,IAAAhO,EAAA,EAAAwJ,EAAA,EAAAC,EAAA;EA0PE,MAAMwF,YAAA,GAAelB,QAAA,CAASkB,YAAA,IAAgB,CAAC;EAE/C,MAAM1H,SAAA,IAAYvH,EAAA,GAAAgO,oBAAA,oBAAAA,oBAAA,CAAsB/M,MAAA,KAAtB,gBAAAjB,EAAA,CAA8BuH,SAAA;EAEhD,MAAMyF,MAAA,KAASxD,EAAA,GAAAwE,oBAAA,CAAqB/M,MAAA,KAArB,gBAAAuI,EAAA,CAA6BiF,eAAA,KAAmB;EAC/D,MAAMxB,OAAA,KAAUxD,EAAA,GAAAuE,oBAAA,CAAqB/M,MAAA,KAArB,gBAAAwI,EAAA,CAA6BiF,gBAAA,KAAoB;EAEjE,IAAI+C,GAAA,GAAMxC,YAAA,CAAanJ,MAAA,CAAOC,IAAA,CAAKkJ,YAAY,EAAE;EAEjD,IAAIwC,GAAA,IAAOA,GAAA,CAAIlK,SAAA,GAAY;IACzBkK,GAAA,GAAMA,GAAA,CAAIlK,SAAA;EACZ;EAEA,OAAO;IACLmK,SAAA,EAAWD,GAAA,CAAInC,OAAA,CAAQ5J,GAAA,CAAKiM,KAAA,KAAgB;MAC1C1S,KAAA,EAAO0S,KAAA,CAAMzL,GAAA;MACb0L,WAAA,EAAatF,aAAA,CACXqF,KAAA,CAAMzL,GAAA,EAEN8H,oBAAA,CAAqB/M,MAAA,CAAOoG,UAAA,IAAc,EAC5C,EACGpD,OAAA,CAAQ,UAAU+I,MAAM,EACxB/I,OAAA,CAAQ,YAAYgJ,OAAO;MAC9B4E,KAAA,EAAOF,KAAA,CAAMzC;IACf,EAAE;IACF8B,qBAAA,EAAuB;IACvBP,gBAAA,EAAkB1C,QAAA,CAAS2C;EAC7B;AACF;;;AClRA,IAAMoB,UAAA,GAAcC,IAAA,IAAoB;EACtC,IAAI,OAAOC,IAAA,KAAS,aAAa;IAC/B,OAAOC,MAAA,CAAOrH,IAAA,CAAKmH,IAAA,CAAKG,QAAA,GAAW,MAAMH,IAAA,CAAKI,QAAQ,EAAE3E,QAAA,CAAS,QAAQ;EAC3E,OAAO;IACL,OAAOwE,IAAA,CAAKD,IAAA,CAAKG,QAAA,GAAW,MAAMH,IAAA,CAAKI,QAAQ;EACjD;AACF;AAEA,SAASC,iBAAiBC,OAAA,EAAiB;EAIzC,IAAIC,SAAA;EACJ,IAAI,OAAOC,IAAA,KAAS,aAAa;IAC/BD,SAAA,GAAYL,MAAA,CAAOrH,IAAA,CAAKyH,OAAA,CAAQ7O,KAAA,CAAM,GAAG,EAAE,IAAI,QAAQ,EAAEgK,QAAA,CAAS;EACpE,OAAO;IACL8E,SAAA,GAAYC,IAAA,CAAKF,OAAA,CAAQ7O,KAAA,CAAM,GAAG,EAAE,EAAE,EAAEA,KAAA,CAAM,GAAG;EACnD;EACA,OAAO,WAAW8O,SAAA,CAAU,MAAMA,SAAA,CAAU;AAC9C;AAEO,IAAME,aAAA,GAAN,MAA2C;EAChDC,YAAmBzR,MAAA,EAAkC0R,QAAA,EAAuB;IAAzD,KAAA1R,MAAA,GAAAA,MAAA;IAAkC,KAAA0R,QAAA,GAAAA,QAAA;EAAwB;EAE7EtS,oCAAoCC,QAAA,EAA2B;IAC7D,OAAOD,mCAAA,CAAoCC,QAAQ;EACrD;EAEA,MAAMsS,sBAAsBtS,QAAA,EAA2B;IACrD,IAAI,KAAKW,MAAA,CAAO4R,IAAA,KAAS,UAAa,KAAK5R,MAAA,CAAO6R,QAAA,KAAa,QAAW;MACxE,MAAM,IAAIpR,KAAA,CACR,iHACF;IACF;IAEA,MAAMmR,IAAA,GAAO,KAAK5R,MAAA,CAAO6R,QAAA,GAAWT,gBAAA,CAAiB,KAAKpR,MAAA,CAAO6R,QAAQ,IAAI,KAAK7R,MAAA,CAAO4R,IAAA;IAEzF,OAAOE,KAAA,CAAM,GAAGF,IAAA,aAAiB;MAC/BG,OAAA,EAAS;QACP,IAAI,KAAK/R,MAAA,CAAOgS,MAAA,GAAS;UAAEC,aAAA,EAAe,UAAU,KAAKjS,MAAA,CAAOgS,MAAA;QAAS,IAAI,CAAC;QAC9E,gBAAgB;QAChB,IAAI,KAAKhS,MAAA,CAAO+R,OAAA,IAAW,CAAC;QAC5B,IAAI,KAAK/R,MAAA,CAAO+Q,IAAA,GACZ;UACEmB,aAAA,EAAe,WAAWpB,UAAA,CAAW,KAAK9Q,MAAA,CAAO+Q,IAAI;QACvD,IACA,CAAC;MACP;MACAlR,IAAA,EAAM,KAAKT,mCAAA,CAAoCC,QAAQ;MACvD8S,MAAA,EAAQ;IACV,CAAC;EACH;EAEA,MAAMC,QAAQ/S,QAAA,EAAiE;IAzDjF,IAAAL,EAAA,EAAAwJ,EAAA,EAAAC,EAAA,EAAAyE,EAAA,EAAAC,EAAA,EAAAC,EAAA;IA0DI,IAAI;MACF,MAAML,QAAA,GAAW,MAAM,KAAK4E,qBAAA,CAAsBtS,QAAQ;MAC1D,MAAMgT,SAAA,GAAY,MAAMtF,QAAA,CAASuF,IAAA,CAAK;MAEtC,IAAI,KAAKZ,QAAA,CAASa,KAAA,EAAO;QACvBC,OAAA,CAAQC,GAAA,CAAI,yBAAyB;QACrCD,OAAA,CAAQC,GAAA,CAAIhT,IAAA,CAAKC,SAAA,CAAU2S,SAAS,CAAC;MACvC;MAEA,IAAIA,SAAA,CAAUK,MAAA,IAAU,KAAK;QAC3BF,OAAA,CAAQG,KAAA,CAAMlT,IAAA,CAAKC,SAAA,CAAU2S,SAAS,CAAC;QACvC,MAAM,IAAI5R,KAAA,CACR,uGACF;MACF,WAAW4R,SAAA,CAAUK,MAAA,KAAW,KAAK;QACnCF,OAAA,CAAQG,KAAA,CAAMlT,IAAA,CAAKC,SAAA,CAAU2S,SAAS,CAAC;QACvC,MAAM,IAAI5R,KAAA,CACR,kTACF;MACF,aAAW+H,EAAA,IAAAxJ,EAAA,GAAAqT,SAAA,CAAUA,SAAA,KAAV,gBAAArT,EAAA,CAAsB,OAAtB,gBAAAwJ,EAAA,CAA0BkK,MAAA,MAAW,KAAK;QACnDF,OAAA,CAAQG,KAAA,CAAMlT,IAAA,CAAKC,SAAA,CAAU2S,SAAS,CAAC;QACvC,MAAM,IAAI5R,KAAA,CACR,kLACF;MACF,WAAW4R,SAAA,CAAUK,MAAA,KAAW,SAAOxF,EAAA,IAAAzE,EAAA,GAAA4J,SAAA,CAAUA,SAAA,KAAV,gBAAA5J,EAAA,CAAsB,OAAtB,gBAAAyE,EAAA,CAA0BwF,MAAA,MAAW,KAAK;QAC/EF,OAAA,CAAQG,KAAA,CAAMlT,IAAA,CAAKC,SAAA,CAAU2S,SAAS,CAAC;QACvC,MAAM,IAAI5R,KAAA,CACR,+EACF;MACF,WAAW4R,SAAA,CAAUK,MAAA,KAAW,SAAOtF,EAAA,IAAAD,EAAA,GAAAkF,SAAA,CAAUA,SAAA,KAAV,gBAAAlF,EAAA,CAAsB,OAAtB,gBAAAC,EAAA,CAA0BsF,MAAA,MAAW,KAAK;QAC/EF,OAAA,CAAQG,KAAA,CAAMlT,IAAA,CAAKC,SAAA,CAAU2S,SAAS,CAAC;QACvC,MAAM,IAAI5R,KAAA,CACR;AAAA;AAAA;AAAA;AAAA;AAAA,WAMF;MACF;MACA,OAAO4R,SAAA,CAAUA,SAAA;IACnB,SAASM,KAAA,EAAP;MACA,MAAMA,KAAA;IACR;EACF;AACF;;;AC9EA,IAAMC,eAAA,GACJvQ,YAAA,IACyB;EACzB,IAAI,CAACA,YAAA,EAAc;IACjB,OAAO,EAAC;EACV;EACA,IAAI,OAAOA,YAAA,KAAiB,UAAU;IACpC,MAAM,CAAC1D,SAAA,EAAWV,KAAK,IAAIoE,YAAA,CAAaG,KAAA,CAAM,GAAG;IACjD,OAAO,CAAC;MAAE7D,SAAA;MAAWV;IAAM,CAAC;EAC9B,OAAO;IAEL,OAAOoE,YAAA,CAAa/C,MAAA,CAA6B,CAACC,GAAA,EAAUc,MAAA,KAAgB;MAC1E,IAAI,OAAOA,MAAA,KAAW,UAAU;QAC9B,MAAM,CAAC1B,SAAA,EAAWV,KAAK,IAAIoC,MAAA,CAAOmC,KAAA,CAAM,GAAG;QAC3C,OAAO,CAAC,GAAGjD,GAAA,EAAK;UAAEZ,SAAA;UAAWV;QAAM,CAAC;MACtC;MACA,OAAO,CAAC,GAAGsB,GAAA,EAAK,GAAGqT,eAAA,CAAgBvS,MAAM,CAAC;IAC5C,GAAG,EAAE;EACP;AACF;AAEO,IAAMwS,+BAAA,GAAkCA,CAC7CC,UAAA,EACAtT,OAAA,EACAQ,MAAA,KACG;EAlDL,IAAAhB,EAAA,EAAAwJ,EAAA,EAAAC,EAAA;EAmDE,MAAMsK,YAAA,GAA6B;IACjChR,KAAA,IAAO/C,EAAA,GAAAQ,OAAA,CAAQS,MAAA,KAAR,gBAAAjB,EAAA,CAAgB+C,KAAA,KAAS;IAChCiR,OAAA,IAASxK,EAAA,GAAAhJ,OAAA,CAAQS,MAAA,KAAR,gBAAAuI,EAAA,CAAgByK,YAAA,KAAgB,EAAC;IAC1C9Q,OAAA,EAASyQ,eAAA,EAAgBnK,EAAA,GAAAjJ,OAAA,CAAQS,MAAA,KAAR,gBAAAwI,EAAA,CAAgBpG,YAAY;EACvD;EAEA,MAAM6Q,cAAA,GAAiBC,iBAAA,CAAkBJ,YAAA,EAAcD,UAAA,IAAc,EAAE;EAEvE,MAAMM,OAAA,GAAUF,cAAA,CAAe5T,MAAA,CAC7B,CAACC,GAAA,EAAK8T,IAAA,KAAS;IACbA,IAAA,CAAKD,OAAA,CAAQ1O,GAAA,CAAK4O,MAAA,IAAW;MAC3B/T,GAAA,CAAI+H,OAAA,GAAU;MACd,IAAIgM,MAAA,CAAOA,MAAA,KAAW,gBAAgB;QACpC/T,GAAA,CAAImI,UAAA,CAAW1F,IAAA,CAAK,GAAGsR,MAAA,CAAOC,WAAW;MAC3C,WAAWD,MAAA,CAAOA,MAAA,KAAW,gBAAgB;QAC3C/T,GAAA,CAAIwC,KAAA,GAAQuR,MAAA,CAAOvR,KAAA;MACrB,WAAWuR,MAAA,CAAOA,MAAA,KAAW,cAAc;QACzC/T,GAAA,CAAIsI,cAAA,CAAe7F,IAAA,CAAK;UACtB3B,MAAA,EAAQ;YACN+C,YAAA,EAAc;cACZrB,KAAA,EAAOc,oBAAA,CACL7C,MAAA,CAAO1B,gBAAA,EACP0B,MAAA,CAAOY,iBAAA,EACP0S,MAAA,CAAOvR,KACT;YACF;UACF;UACAmG,MAAA,EAAQoL,MAAA,CAAOpL;QACjB,CAAC;MACH,WAAWoL,MAAA,CAAOA,MAAA,KAAW,kBAAkB;QAC7C/T,GAAA,CAAI+Q,QAAA,CAAStO,IAAA,CAAKvC,IAAA,CAAK+T,KAAA,CAAMF,MAAA,CAAOhD,QAAQ,CAAC;MAC/C,WAAWgD,MAAA,CAAOA,MAAA,KAAW,qBAAqB;QAChD/T,GAAA,CAAIyH,oBAAA,GAAuBsM,MAAA,CAAOtM,oBAAA;MACpC,WAAWsM,MAAA,CAAOA,MAAA,KAAW,eAAe;QAC1C/T,GAAA,CAAIsJ,WAAA,CAAY7G,IAAA,CAAK;UACnBoB,YAAA,EAAc;YACZrB,KAAA,EAAOc,oBAAA,CACL7C,MAAA,CAAO1B,gBAAA,EACP0B,MAAA,CAAOY,iBAAA,EACP0S,MAAA,CAAOvR,KACT;UACF;QACF,CAAC;MACH;IACF,CAAC;IACD,OAAOxC,GAAA;EACT,GACA;IACEuQ,OAAA,EAASoD,cAAA,CAAexO,GAAA,CAAK2O,IAAA,IAASA,IAAA,CAAKI,EAAE;IAC7C/L,UAAA,EAAY,EAAC;IACbG,cAAA,EAAgB,EAAC;IACjB9F,KAAA,EAAOgR,YAAA,CAAahR,KAAA;IACpBuO,QAAA,EAAU,EAAC;IACXtJ,oBAAA,EAAsB;IACtBM,OAAA,EAAS;IACTuB,WAAA,EAAa;EACf,CACF;EAEA,OAAOuK,OAAA;AACT;AAEO,IAAMD,iBAAA,GAAoBA,CAACJ,YAAA,EAA4BW,KAAA,KAC5DA,KAAA,CAAMrT,MAAA,CACHsT,OAAA,IACCA,OAAA,CAAQC,UAAA,CAAWnV,IAAA,CAChB4U,IAAA,IACCA,IAAA,CAAKhT,MAAA,CAAQwT,SAAA,IAAc;EACzB,IAAIA,SAAA,CAAUb,OAAA,KAAY,WAAWa,SAAA,CAAUC,UAAA,KAAe,SAAS;IACrE,OAAOD,SAAA,CAAU5V,KAAA,KAAU8U,YAAA,CAAahR,KAAA;EAC1C;EACA,IAAI8R,SAAA,CAAUb,OAAA,KAAY,WAAWa,SAAA,CAAUC,UAAA,KAAe,YAAY;IACxE,OAAOf,YAAA,CAAahR,KAAA,CAAM7C,QAAA,CAAS2U,SAAA,CAAU5V,KAAK;EACpD;EACA,IAAI4V,SAAA,CAAUb,OAAA,KAAY,WAAWa,SAAA,CAAUC,UAAA,KAAe,UAAU;IACtE,OAAOf,YAAA,CAAahR,KAAA,CAAMgS,UAAA,CAAWF,SAAA,CAAU5V,KAAK;EACtD;EACA,IAAI4V,SAAA,CAAUb,OAAA,KAAY,WAAW;IACnC,OAAOa,SAAA,CAAU5V,KAAA,CAAM+V,IAAA,CAAM/V,KAAA,IAAU8U,YAAA,CAAaC,OAAA,CAAQ9T,QAAA,CAASjB,KAAK,CAAC;EAC7E;EACA,IAAI4V,SAAA,CAAUb,OAAA,KAAY,iBAAiB;IACzC,OAAOa,SAAA,CAAU5E,MAAA,CAAOgF,KAAA,CACrBhW,KAAA,IACC8U,YAAA,CAAa5Q,OAAA,CAAQ1D,IAAA,CAClB4B,MAAA,IAAWA,MAAA,CAAO1B,SAAA,KAAcV,KAAA,CAAMU,SAAA,IAAa0B,MAAA,CAAOpC,KAAA,KAAUA,KAAA,CAAMA,KAC7E,MAAM,MACV;EACF;EAEA,OAAO;AACT,CAAC,EAAE+G,MAAA,KAAWqO,IAAA,CAAKrO,MACvB,MAAM,MACV;;;ACnIF,IAAqBkP,SAAA,GAArB,MAA+B;EAG7BzC,YAAoBzR,MAAA,EAAiC0R,QAAA,GAAwB;IAAEa,KAAA,EAAO;EAAM,GAAG;IAA3E,KAAAvS,MAAA,GAAAA,MAAA;IAAiC,KAAA0R,QAAA,GAAAA,QAAA;IACnD,KAAKyC,WAAA,GACH,aAAanU,MAAA,CAAOoU,UAAA,GAChBpU,MAAA,CAAOoU,UAAA,GACP,IAAI5C,aAAA,CAAcxR,MAAA,CAAOoU,UAAA,EAAY1C,QAAQ;EACrD;EAEA,MAAc2C,cAAchV,QAAA,EAA2B;IACrD,IAAI;MACF,IAAI,KAAKqS,QAAA,CAASa,KAAA,EAAO;QACvBC,OAAA,CAAQC,GAAA,CAAI,kCAAkC;QAC9CD,OAAA,CAAQC,GAAA,CAAI,gBAAgB;QAC5BD,OAAA,CAAQC,GAAA,CAAIrT,mCAAA,CAAoCC,QAAQ,CAAC;MAC3D;MACA,MAAMgT,SAAA,GAAY,MAAM,KAAK8B,WAAA,CAAY/B,OAAA,CAAQ/S,QAAQ;MACzD,OAAOgT,SAAA;IACT,SAASiC,GAAA,EAAP;MACA9B,OAAA,CAAQG,KAAA,CAAM2B,GAAG;MACjB,OAAO,EAAC;IACV;EACF;EAEA,MAAMC,4BACJC,qBAAA,EACAjM,cAAA,EACA;IAxCJ,IAAAvJ,EAAA,EAAAwJ,EAAA;IAyCI,IAAI,CAACgM,qBAAA,IAAyBrU,KAAA,CAAMC,OAAA,CAAQoU,qBAAqB,MAAM,OAAO;MAC5EhC,OAAA,CAAQC,GAAA,CAAI;QAAE+B;MAAsB,CAAC;MACrC,MAAM,IAAI/T,KAAA,CACR,yNACF;IACF;IAEA,MAAMqS,UAAA,GAAa,KAAK9S,MAAA,CAAOyU,eAAA,CAAgBC,WAAA,IAAe,EAAC;IAE/D,MAAMC,uBAAA,GAA8CH,qBAAA,CAAsB9P,GAAA,CAAKlF,OAAA,IAAY;MACzF,OAAOqT,+BAAA,CAAgCC,UAAA,EAAYtT,OAAA,EAAS,KAAKQ,MAAA,CAAOyU,eAAe;IACzF,CAAC;IAED,IAAIG,UAAA,GAA8BJ,qBAAA,CAAsB9P,GAAA,CAAI,CAAClF,OAAA,EAASqV,CAAA,MAAO;MAC3EhV,IAAA,EAAMwL,gBAAA,CACJ7L,OAAA,EACA,KAAKQ,MAAA,CAAOyU,eAAA,EACZE,uBAAA,CAAwBE,CAAA,GACxBtM,cACF;MACA/I,OAAA;MACAI,SAAA,EAAW4F,YAAA,CAAahG,OAAA,CAAQI,SAAA,EAAW,KAAKI,MAAA,CAAOyU,eAAe;IACxE,EAAE;IAEF,KAAIzV,EAAA,GAAAuJ,cAAA,oBAAAA,cAAA,CAAgBuM,KAAA,KAAhB,gBAAA9V,EAAA,CAAuB+V,YAAA,EAAc;MACvCH,UAAA,GAAa,MAAMrM,cAAA,CAAeuM,KAAA,CAAMC,YAAA,CAAaH,UAAU;IACjE;IAEA,IAAII,WAAA,GAAc,MAAM,KAAKX,aAAA,CAAcO,UAAU;IAErD,KAAIpM,EAAA,GAAAD,cAAA,oBAAAA,cAAA,CAAgBuM,KAAA,KAAhB,gBAAAtM,EAAA,CAAuByM,WAAA,EAAa;MACtCD,WAAA,GAAc,MAAMzM,cAAA,CAAeuM,KAAA,CAAMG,WAAA,CAAYL,UAAA,EAAYI,WAAW;IAC9E;IAEA,IAAI;MACF,MAAME,sBAAA,GAAyBF,WAAA,CAAYtQ,GAAA,CAAI,CAACqI,QAAA,EAAU8H,CAAA,KAAM;QA5EtE,IAAAM,GAAA;QA8EQ,KAAIA,GAAA,GAAAX,qBAAA,CAAsBK,CAAA,EAAG5U,MAAA,KAAzB,gBAAAkV,GAAA,CAAiC5O,SAAA,EAAW;UAC9C,OAAOiK,4BAAA,CAA6BzD,QAAA,EAAUyH,qBAAA,CAAsBK,CAAA,CAAE;QACxE;QACA,OAAOjF,iBAAA,CACL7C,QAAA,EACAyH,qBAAA,CAAsBK,CAAA,GACtB,KAAK7U,MAAA,CAAOyU,eAAA,EACZE,uBAAA,CAAwBE,CAAA,CAC1B;MACF,CAAC;MAED,OAAO;QACLO,OAAA,EAASF;MACX;IACF,SAASZ,GAAA,EAAP;MACA9B,OAAA,CAAQG,KAAA,CAAM2B,GAAG;MACjB,MAAM,IAAI7T,KAAA,CACR,wIACF;IACF;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}